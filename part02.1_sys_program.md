<计算机网络> <操作系统原理> <编译原理>
浮点型数在转二进制时存在一定的舍弃,在转回10进制时取得的是近似数
修饰符 %-10s 左对齐,占10个宽度
break 不可推导
快速排序计算时间复杂度

#####vscode添加书签:
按ctrl+p,输入:
ext install alefragnani.Bookmarks

#####Java 包括两种数据类型：
原始数据类型（primitive data type）：byte,short, char, int, long,float,double,boolean. 一共8种
对象（Object）：8中除外的都是对象，包括数组。
显然char属于基本数据类型（即原始数据类型），string属于对象


#####优化代码的几种思路
    在选择性执行语句中,把执行率高的先判断执行
    尽量使用内嵌函数和标准库
当input()函数由用户输入时,或多或少会多几个空格,用strip()函数进行处理
避免tcp套接字粘包,使用sleep(xx)函数
第二阶段重点掌握多线程并发和IO并发
排序算法稳定性:在经过排序之后,相同关键字元素的相对位置不发生变化

模块:.py文件为一个模块
顶层模块:调用功能模块
功能模块:实现特定功能,一般不直接启动,被其他模块调用
####操作系统,shell,与硬件
操作系统的作用:它是一个大的软件平台,在硬件与软件之间建立连接,为软件的运行提供平台
shell命令:linux 操作系统的内置命令,特点是命令的启动非常迅速
####同步与异步
同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。  
异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。

####程序的执行效率
第二阶段的内容与程序的执行效率挂钩

####区别容器,迭代器,生成器与可迭代对象
    容器(container)：容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个的迭代获取，可以用in,not in关键字判断元素是否包含在容器中，常见的容器有list,set,dict,tuple,str可以把容器看做是一个盒子，一栋房子。

    可迭代对象：可迭代对象内部实现了__iter__方法，调用该方法返回一个迭代器对象，迭代器内部保持一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。我们把可以通过for .. in 这类语句迭代读取一条数据供我们使用的对象称为可迭代对象。

    迭代器：一个实现了__iter__方法和__next__方法的对象就是迭代器，迭代器同时也是一个可迭代对象，我们可以通过调用__iter__方法来获取迭代器，可以用过__next__方法来取得下一个位置的值。
    迭代器与列表的区别:迭代器不像列表一样把所有元素一次性加载到内存，而是以一种延迟计算的方式返回元素，比如一个列表中有一千万个整数，需要占用超过400M的内存，而迭代器只需要几十个字节的空间，因为它并没有把所有元素装载到内存，而是等到调用next 方法的时候才返回改元素。	

    生成器：生成器是一种特殊的迭代器，它比迭代器更优雅，创建生成器的方式有 1.可以使用推导式，把列表推导式的[] 换成() 2.在函数中使用yield关键字返回，就变成了生成器，使用了yield关键字的函数不再是函数，而是生成器
    yield关键字的作用：
    保存当前运行状态（断点），然后暂停执行，即将生成器（函数）挂起
    将yield关键字后面表达式的值作为返回值返回，此时可以理解为起到了return的作用
    可以使用next()函数让生成器从断点处继续执行，即唤醒生成器（函数，也可以使用send唤醒


    1.容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器，容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。

    2.可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。

    3.迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。

    4.生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield
    --------------------- 


数据结构 
==========================

| Tedu Python 教学部 |
| --- |
| Author：吕泽|
| Days：2天|

-----------

[TOC]

## 数据结构基本概念
## 逻辑模型和存储模型的设计
### 常见的数据结构模型设计(线性,链式,表,栈,队列,二叉树)

### 什么是数据结构？

1. 数据
> 数据即信息的载体，是能够输入到计算机中并且能被计算机识别、存储和处理的符号总称。

2. 数据元素
> 数据元素是数据的基本单位，又称之为记录（Record）。一般，数据元素由若干基本项（或称字段、域、属性）组成。   

3. 数据结构
> 数据结构指的是数据元素及数据元素之间的相互关系，或组织数据的形式。

### 数据之间的结构关系

1. 逻辑结构

> 表示数据之间的抽象关系（如邻接关系、从属关系等），按每个元素可能具有的直接前趋数和直接后继数将逻辑结构分为“线性结构”和“非线性结构”两大类。

2. 存储结构
   
> 逻辑结构在计算机中的具体实现方法，分为顺序存储方法、链接存储方法、索引存储方法、散列存储方法。

### 逻辑结构（关系）

1. 特点：
* 只是描述数据结构中数据元素之间的联系规律
* 是从具体问题中抽象出来的数学模型，是独立于计算机存储器的（与机器无关）

2. 逻辑结构分类

* 线性结构
  
> 对于数据结构课程而言，简单地说，线性结构是n个数据元素的有序（次序）集合。
>> - 集合中必存在唯一的一个"第一个元素"；
>> - 集合中必存在唯一的一个"最后的元素"；
>> - 除最后元素之外，其它数据元素均有唯一的"后继"；
>> - 除第一元素之外，其它数据元素均有唯一的"前驱"。

* 树形结构（层次结构）
    
>树形结构指的是数据元素之间存在着“一对多”的树形关系的数据结构，是一类重要的非线性数据结构。在树形结构中，树根结点没有前驱结点，其余每个结点有且只有一个前驱结点。叶子结点没有后续结点，其余每个结点的后续节点数可以是一个也可以是多个。
   
* 图状结构（网状结构）

>图是一种比较复杂的数据结构。在图结构中任意两个元素之间都可能有关系，也就是说这是一种多对多的关系。

* 其他结构

>除了以上几种常见的逻辑结构外，数据结构中还包含其他的结构，比如集合等。有时根据实际情况抽象的模型不止是简单的某一种，也可能拥有更多的特征。

![逻辑结构](./mark_down_img/data1.png)

### 存储结构（关系）

1. 特点：
* 是数据的逻辑结构在计算机存储器中的映象（或表示）
* 存储结构是通过计算机程序来实现的，因而是依赖于具体的计算机语言的。

2. 存储结构分类
   
* 顺序存储    
>顺序存储（Sequential Storage）：将数据结构中各元素按照其逻辑顺序存放于存储器一片连续的存储空间中。
>节约空间,存储空间利用率高

* 链式存储
>链式存储（Linked Storage）：将数据结构中各元素分布到存储器的不同点，用记录下一个结点位置的方式建立它们之间的联系，由此得到的存储结构为链式存储结构。
>插入或删除元素时很方便

* 比较
>   顺序表适宜做查找这样的静态操作
    链表宜做插入,删除这样的动态操作

    因为顺序表在做动态操作时平均移动一半的元素,链表不需移动元素,只需移动指针.

* 结论
若线性表的长度变化不大,且主要做查找操作,宜选用顺序表
若线性表的长度变化较大,且主要做插入,删除之类的操作,宜选用链表


* 索引存储
>索引存储（Indexed Storage）：在存储数据的同时，建立一个附加的索引表，即索引存储结构=数据文件+索引表。 
    

## 线性表

线性表的定义是描述其逻辑结构，而通常会在线性表上进行的查找、插入、删除等操作。
线性表作为一种基本的数据结构类型，在计算机存储器中的映象（或表示）一般有两种形式，一种是顺序映象，一种是链式映象。

### 线性表的顺序存储

1. 定义
>若将线性表L=(a0,a1, ……,an-1)中的各元素依次存储于计算机一片连续的存储空间，这种机制表示为线性表的顺序存储结构。

2. 特点
>* 逻辑上相邻的元素 ai, ai+1，其存储位置也是相邻的；
>* 存储密度高，方便对数据的遍历查找。
>* 对表的插入和删除等运算的效率较差。

3. 程序实现

> 在Python中，list存放于一片单一连续的内存块，故可借助于列表类型来描述线性表的顺序存储结构，而且列表本身就提供了丰富的接口满足这种数据结构的运算。

```python
>>>L = [1,2,3,4]
>>>L.append(10)      #尾部增加元素
L
[1, 2, 3, 4, 10]

>>>L.insert(1,20)    #插入元素
L
[1, 20, 2, 3, 4, 10]

>>>L.remove(3)       #删除元素
L
[1, 20, 2, 4, 10]     

>>>L[4] = 30         #修改
L
[1, 20, 2, 4, 30]

>>>L.index(2)        #查找
2
```

### 线性表的链式存储

1. 定义
>将线性表L=(a0,a1,……,an-1)中各元素分布在存储器的不同存储块，称为结点，每个结点（尾节点除外）中都持有一个指向下一个节点的引用，这样所得到的存储结构为链表结构。

>不同的链表对象,即使全部属性相同"=="判断也是False

![链表结构](./mark_down_img/data2.png)

2. 特点
>* 逻辑上相邻的元素 ai, ai+1，其存储位置也不一定相邻；
>* 存储稀疏，不必开辟整块存储空间。
>* 对表的插入和删除等运算的效率较高。
>* 逻辑结构复杂，不利于遍历。


3. 程序实现

  ***代码实现：  day1/linklist.py***

## 栈和队列

### 栈

1. 定义
>栈是限制在一端进行插入操作和删除操作的线性表（俗称堆栈），允许进行操作的一端称为“栈顶”，另一固定端称为“栈底”，当栈中没有元素时称为“空栈”。

2. 特点：

>* 栈只能在一端进行数据操作
>* 栈模型具有先进后出或者叫做后进先出的规律

#### 栈的应用
>    逆序输出(倒序切片)
    括号匹配


![栈](mark_down_img/data5.png)

3. 栈的代码实现 

栈的操作有入栈（压栈），出栈（弹栈），判断栈的空满等操作。

***顺序存储代码实现： day1/sstack.py***
***链式存储代码实现： day1/lstack.py***

### 队列

1. 定义
>队列是限制在两端进行插入操作和删除操作的线性表，允许进行存入操作的一端称为“队尾”，允许进行删除操作的一端称为“队头”。

2. 特点：

>* 队列只能在队头和队尾进行数据操作
>* 队列模型具有先进先出或者叫做后进后出的规律

####队列的应用
>    高并发时异步处理
     

![队列](mark_down_img/data6.png)

3. 队列的代码实现 

队列的操作有入队，出队，判断队列的空满等操作。

***顺序存储代码实现： day2/squeue.py***
***链式存储代码实现： day2/lqueue.py***

## 树形结构

###  基础概念 

1. 定义
>树（Tree）是n（n≥0）个节点的有限集合T，它满足两个条件：有且仅有一个特定的称为根（Root）的节点；其余的节点可以分为m（m≥0）个互不相交的有限集合T1、T2、……、Tm，其中每一个集合又是一棵树，并称为其根的子树（Subtree）。

![](mark_down_img/data7.png)


2. 基本概念 
 
>* 一个节点的子树的个数称为该节点的度数，一棵树的度数是指该树中节点的最大度数。

>* 度数为零的节点称为树叶或终端节点，度数不为零的节点称为分支节点，除根节点外的分支节点称为内部节点。

>* 一个节点的子树之根节点称为该节点的子节点，该节点称为它们的父节点，同一节点的各个子节点之间称为兄弟节点。一棵树的根节点没有父节点，叶节点没有子节点。

>* 一个节点系列k1,k2, ……,ki,ki+1, ……,kj,并满足ki是ki+1的父节点，就称为一条从k1到kj的路径，路径的长度为j-1,即路径中的边数。路径中前面的节点是后面节点的祖先，后面节点是前面节点的子孙。

>* 节点的层数等于父节点的层数加一，根节点的层数定义为一。树中节点层数的最大值称为该树的高度或深度。

>* m（m≥0）棵互不相交的树的集合称为森林。树去掉根节点就成为森林，森林加上一个新的根节点就成为树。

![](mark_down_img/data8.png)

####树的应用
    在计算机体系中，树的地位是无可替代的。
    计算机的核心是计算和储存，而树有效地解决了储存的问题和计算时程序调用的问题。

    树最强大的功能是进行储存查询

    树形结构在算法设计中也有着广泛的应用，其关键在于许多算法在设计的过程中采用了分治的思想，使用了递归求解的方法或者需要遍历可行解，这些程序的运行均可用树形结构表达，辅助人们理解。






### 二叉树

####二叉树的用途
二叉查找树
![](mark_down_img/bint_tree_1.jpg)

![](mark_down_img/bint_tree_2.jpg)

#### 定义与特征

1. 定义
>二叉树（Binary Tree）是n（n≥0）个节点的有限集合，它或者是空集（n＝0），或者是由一个根节点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。二叉树与普通有序树不同，二叉树严格区分左孩子和右孩子，即使只有一个子节点也要区分左右。

![](mark_down_img/data9.png)

2. 二叉树的特征

* 二叉树第i（i≥1）层上的节点最多为$2^{i-1}$个。
* 深度为k（k≥1）的二叉树最多有$2^k－1$个节点。
* 在任意一棵二叉树中，树叶的数目比度数为2的节点的数目多一。

* 满二叉树 ：深度为k（k≥1）时有$2^k－1$个节点的二叉树。
* 完全二叉树 ：只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边的若干位置上。


#### 二叉树的遍历

>遍历 ：沿某条搜索路径周游二叉树，对树中的每一个节点访问一次且仅访问一次。

> 先序遍历： 先访问树根，再访问左子树，最后访问右子树；
> 中序遍历： 先访问左子树，再访问树根，最后访问右子树；
> 后序遍历： 先访问左子树，再访问右子树，最后访问树根；
> 层次遍历:  从根节点开始，逐层从左向右进行遍历。



#### 二叉树的代码实现

##### 二叉树顺序存储

二叉树本身是一种递归结构，可以使用Python list 进行存储。但是如果二叉树的结构比较稀疏的话浪费的空间是比较多的。

* 空结点用None表示
* 非空二叉树用包含三个元素的列表[d,l,r]表示，其中d表示根结点，l，r左子树和右子树。

```
['A',['B',None,None
     ],
     ['C',['D',['F',None,None],
               ['G',None,None],
          ],     
          ['E',['H',None,None],
               ['I',None,None],
          ],
     ]
]
```

![](mark_down_img/bitree1.png)


##### 二叉树链式存储

***二叉树遍历： day2/bitree.py***



#### 递归思想和实践

递归
linux ubuntu 系统最大递归层数为1000
递归的运行效率低(开辟栈),一般不提倡用递归算法设计程序
优点：

    1.简洁:
        先写出终止表达时,再写终止表达式的下一步,验证

    2.在树的前序，中序，后序遍历算法中，递归的实现明显要比循环简单得多。

缺点：

    1.递归由于是函数调用自身，而函数调用是有时间和空间的消耗的：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址以及临时变量，而往栈中压入数据和弹出数据都需要时间。->效率

    2.递归中很多计算都是重复的，由于其本质是把一个问题分解成两个或者多个小问题，多个小问题存在相互重叠的部分，则存在重复计算，如fibonacci斐波那契数列的递归实现。->效率

    3.调用栈可能会溢出，其实每一次函数调用会在内存栈中分配空间，而每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。->性能

###指数与对数
==============================
###二叉树的遍历
####中序遍历投影法

![中序遍历投影法](mark_down_img/InOrder.jpg)

####前序遍历查找路径
![前序遍历查找路径](mark_down_img/PreOrder.jpg)



####递归思想
    很多情况用迭代远远比用递归好了解, 其次, 相对来说, 递归的效率往往要低于迭代的实现, 同时, 递归内存占用也会更大

####递归使用的地方
    遍历查找非文件夹的文件

    案例1： 反转字符串
    案例2：Fibonacci数列
    案例3：汉诺塔问题
    案例4：实现strlen
    案例5：全排列
    阶乘
    二分法查找符合条件的量

1. 什么是递归？
  
>所谓递归函数是指一个函数的函数体中直接调用或间接调用了该函数自身的函数。这里的直接调用是指一个函数的函数体中含有调用自身的语句，间接调用是指一个函数在函数体里有调用了其它函数，而其它函数又反过来调用了该函数的情况。

2. 递归函数调用的执行过程分为两个阶段
  
>递推阶段：从原问题出发，按递归公式递推从未知到已知，最终达到递归终止条件。
>回归阶段：按递归终止条件求出结果，逆向逐步代入递归公式，回归到原问题求解。

3. 优点与缺点
 
>优点：递归可以把问题简单化，让思路更为清晰,代码更简洁
>缺点：递归因系统环境影响大，当递归深度太大时，可能会得到不可预知的结果

***递归示例： day2/recursion.py***
## 算法基础

### 基础概念特征

1. 定义
>算法（Algorithm）是一个有穷规则（或语句、指令）的有序集合。它确定了解决某一问题的一个运算序列。对于问题的初始输入，通过算法有限步的运行，产生一个或多个输出。

数据的逻辑结构与存储结构密切相关:

* 算法设计:  取决于选定的逻辑结构
* 算法实现: 依赖于采用的存储结构


2. 算法的特性
   
* 有穷性 —— 算法执行的步骤（或规则）是有限的；
* 确定性 —— 每个计算步骤无二义性；
* 可行性 —— 每个计算步骤能够在有限的时间内完成；
* 输入 ，输出 —— 存在数据的输入和出输出

3. 评价算法好坏的方法
   
- 正确性：运行正确是一个算法的前提。
- 可读性：容易理解、容易编程和调试、容易维护。
- 健壮性：考虑情况全面，不容以出现运行错误。
- 时间效率高：算法消耗的时间少。
- 储存量低：占用较少的存储空间。

### 时间复杂度计算

算法效率——用依据该算法编制的程序在计算机上执行所消耗的时间来度量。“O”表示一个数量级的概念。根据算法中语句执行的最大次数（频度）来 估算一个算法执行时间的数量级。

> 计算方法：
>> 写出程序中所有运算语句执行的次数，进行加和
>> 如果得到的结果是常量则时间复杂度为1
>> 如果得到的结果中存在变量n则取n的最高次幂作为时间复杂度

下图表示随问题规模n的增大，算法执行时间的增长率。

![常见量级](mark_down_img/data11.png)

### 排序和查找

#### 排序

排序(Sort)是将无序的记录序列（或称文件）调整成有序的序列。

常见排序方法：

* 冒泡排序

>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

* 选择排序

>工作原理为，首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。

* 插入排序

> 对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

* 快速排序

>步骤:
>>从数列中挑出一个元素，称为 "基准"（pivot），
>>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
>>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

***常见排序代码实现： day3/sort.py***

#### 查找

查找(或检索)是在给定信息集上寻找特定信息元素的过程。

##### 二分法查找

当数据量很大适宜采用该方法。采用二分法查找时，数据需是排好序的。

***二分查找代码实现： day3/search.py***




IO网络编程
==========================
网络是io的一种
| Tedu Python 教学部 |
| --- |
| Author：吕泽|
| Days：3天|

-----------



## Linux 操作系统及其组成

1. 操作系统的作用

操作系统（OS）是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务。操作系统也提供一个让用户与系统交互的操作界面。

2. Linux操作系统组成

 一个典型的Linux操作系统组成为：Linux内核，文件系统，命令行shell，图形界面和桌面环境，并包各种工具和应用软件。

 * Linux内核: Linux操作系统的核心代码
  
 * 文件系统：通常指称管理磁盘数据的系统，可将数据以目录或文件的型式存储。每个文件系统都有自己的特殊格式与功能

 * shell命令： 接收用户命令，然后调用相应的应用程序，并根据用户输入的指令来反馈给用户指定的信息。

![Linux](mark_down_img/linux.jpg)

## shell命令
Shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行
### 文件操作命令

* linux下的目录结构

![Linux](mark_down_img/linux_fs.jpg)

| 作用 | 命令 |
| --- | --- |
| 切换工作目录 | cd |
| 查看文件 | ls  ，  ls -l ，  ls -a |
| 复制文件 | cp  -r |
| 移动文件 | mv |
| 删除文件 | rm  -rf  ， rmdir |
| 创建文件夹| mkdir -p |
| 创建文件| touch |
| 查看文件内容| cat |


## IO 
	
1. 定义

>在内存中存在数据交换的操作,比如和终端交互 ,和磁盘交互，和网络交互等

2. 程序分类

>* IO密集型程序：在程序执行中有大量IO操作，而cpu运算较少。消耗cpu较少，耗时长。

>* 计算密集型程序：程序运行中计算较多，IO操作相对较少。cpu消耗多，执行速度快，几乎没有阻塞。

## 文件

文件是保存在持久化存储设备(硬盘、U盘、光盘..)上的一段数据。从功能角度分为文本文件（打开后会自动解码为字符）、二进制文件(视频、音频等)。在Python里把文件视作一种类型的对象，类似之前学习过的其它类型。

### 字节串（bytes）

在python3中引入了字节串的概念，与str不同，字节串以字节序列值表达数据，更方便用来处理二进程数据。因此在python3中字节串是常见的二进制数据展现方式。

* 普通的ascii编码字符串可以在前面加b转换为字节串，例如：b'hello'
* 字符串转换为字节串方法 ：str.encode()
* 字节串转换为字符串方法 : bytes.decode() 


### 文件读写

对文件实现读写的基本操作步骤为：打开文件，读写文件，关闭文件

***代码实现：  day1/file_open.py***
***代码实现：  day1/file_read.py***
***代码实现：  day1/file_write.py***

1. 打开文件

```python
file_object = open(file_name, access_mode='r', buffering=-1)
功能：打开一个文件，返回一个文件对象。
参数：file_name  文件名；
     access_mode  打开文件的方式,如果不写默认为‘r’ 
          文件模式                        操作
              r                    以读方式打开 文件必须存在
              w                    以写方式打开
                                   文件不存在则创建，存在清空原有内容 
              a                    以追加模式打开 
              r+                   以读写模式打开 文件必须存在
              w+                   以读写模式打开文件
                                   不存在则创建，存在清空原有内容
              a+                   以读写模式打开 追加模式
              rb                   以二进制读模式打开 同r
              wb                   以二进制写模式打开 同w
              ab                   以二进制追加模式打开 同a
              rb+                  以二进制读写模式打开 同r+
              wb+                  以二进制读写模式打开 同w+
              ab+                  以二进制读写模式打开 同a+
     buffering  1表示有行缓冲，默认则表示使用系统默认提供的缓冲机制。
返回值：成功返回文件操作对象。
```

>缓冲:系统自动的在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，再由缓冲区送到磁盘中去。从磁盘中读数据，则一次从磁盘文件将一批数据读入到内存缓冲区中，然后再从缓冲区将数据送到程序的数据区。


1. 读取文件

>read([size])
>功能： 用来直接读取文件中字符。
>参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size最多读取给定数目个字符（字节）。
>返回值： 返回读取到的内容
>* 注意：文件过大时候不建议直接读取到文件结尾，读到文件结尾会返回空字符串。

>readline([size])
>功能： 用来读取文件中一行
>参数： 如果没有给定size参数（默认值为-1）或者size值为负，表示读取一行，给定size表示最多读取制定的字符（字节）。
>返回值： 返回读取到的内容

>readlines([sizeint])
>功能： 读取文件中的每一行作为列表中的一项
>参数： 如果没有给定size参数（默认值为-1）或者size值为负，文件将被读取直至末尾，给定size表示读取到size字符所在行为止。
>返回值： 返回读取到的内容列表


>文件对象本身也是一个可迭代对象，在for循环中可以迭代文件的每一行。
```python
for line in f:
     print(line)
```

3. 写入文件

>write(string)
>功能: 把文本数据或二进制数据块的字符串写入到文件中去
>参数：要写入的内容
>* 如果需要换行要自己在写入内容中添加\n

>writelines(str_list)
>功能：接受一个字符串列表作为参数，将它们写入文件。
>参数: 要写入的内容列表

4. 关闭文件

打开一个文件后我们就可以通过文件对象对文件进行操作了，当操作结束后使用close（）关闭这个对象可以防止一些误操作，也可以节省资源。

>file_object.close()

5. with操作

python中的with语句使用于对资源进行访问的场合，保证不管处理过程中是否发生错误或者异常都会执行规定的“清理”操作，释放被访问的资源，比如有文件读写后自动关闭、线程中锁的自动获取和释放等。

with语句的语法格式如下：

```python
with context_expression [as target(s)]:
    with-body
```

通过with方法可以不用close(),因为with生成的对象在语句块结束后会自动处理，所以也就不需要close了，但是这个文件对象只能在with语句块内使用。

```python
with open('file','r+') as f:
    f.read()
``` 

>注意
>> 1. 加b的打开方式读写要求必须都是字节串
>> 2. 无论什么缓冲，当程序结束或者文件被关闭时都会将缓冲区内容写入磁盘

### 其他操作

#### 刷新缓冲区

***代码实现：  day1/buffer.py***

>flush()
该函数调用后会进行一次磁盘交互，将缓冲区中的内容写入到磁盘。

#### 文件偏移量

***代码实现：  day1/seek.py***

1. 定义
>打开一个文件进行操作时系统会自动生成一个记录，记录中描述了我们对文件的一系列操作。其中包括每次操作到的文件位置。文件的读写操作都是从这个位置开始进行的。

2. 基本操作
   
>tell()
功能：获取文件偏移量大小

>seek(offset[,whence])
功能:移动文件偏移量位置
参数：offset  代表相对于某个位置移动的字节数。负数表示向前移动，正数表示向后移动。
     whence是基准位置的默认值为 0，代表从文件开头算起，1代表从当前位置算起，2 代表从文件末尾算起。
>* 必须以二进制方式打开文件时基准位置才能是1或者2

#### 文件描述符

1. 定义
>系统中每一个IO操作都会分配一个整数作为编号，该整数即这个IO操作的文件描述符。

2. 获取文件描述符
   
>fileno()
通过IO对象获取对应的文件描述符


### 文件管理函数

1. 获取文件大小  
>os.path.getsize(file)
   
2. 查看文件列表  
>os.listdir(dir)
 
3. 查看文件是否存在
>os.path.exists(file)

4. 判断文件类型
>os.path.isfile(file)

5. 删除文件
>os.remove(file)








####day 5
    读写缓冲区  
    文件偏移量
    文件处理函数  操作系统分配整数,识别文件的标志.(文件标识符)
            os模块 和操作系统相关
            sys   在OS基础上增加了python的风格

#####网络编程
## 网络编程基础

计算机网络功能主要包括实现资源共享，实现数据信息的快速传递。
	
### 
七层模型
	   
>制定组织： ISO（国际标准化组织）

>作用：使网络通信工作流程标准化

>应用层 ： 提供用户服务，具体功能有应用程序实现
http,https,ftp,smtp,pop3
>表示层 ： 数据的压缩优化加密
约定语言,信息加密等
>会话层 ： 建立用户级的连接，选择适当的传输服务
>传输层 ： 提供传输服务 
扮演邮递员的角色
>网络层 ： 路由选择，网络互联 
ip寻址,选择路由
>链路层 ： 进行数据交换，控制具体数据的发送
>物理层 ： 提供数据传输的硬件保证，网卡接口，传输介质

>优点 
>1. 建立了统一的工作流程
>2. 分部清晰，各司其职，每个步骤分工明确
>3. 降低了各个模块之间的耦合度，便于开发


### 四层模型（TCP/IP模型）

背景 ： 实际工作中工程师无法完全按照七层模型要求操作，逐渐演化为更符合实际情况的四层

![TCP/IP模型](mark_down_img/1_tcpip模型.png)

#### 数据传输过程
  
1. 发送端由应用程序发送消息，逐层添加首部信息，最终在物理层发送消息包。
2. 发送的消息经过多个节点（交换机，路由器）传输，最终到达目标主机。
3. 目标主机由物理层逐层解析首部消息包，最终到应用程序呈现消息。
   
![TCP/IP模型](mark_down_img/1_TCP.png)

#### 网络协议
	   
>在网络数据传输中，都遵循的规定，包括建立什么样的数据结构，什么样的特殊标志等。
	

### 网络基础概念
		 
* IP地址
>功能：确定一台主机的网络路由位置

>查看本机网络地址命令： ifconfig

>结构
>>IPv4  点分十进制表示 172.40.91.185 每部分取值范围0--255
>>IPv6  128位 扩大了地址范围
				
			
* 域名
>定义： 给网络服务器地址起的名字

>作用： 方便记忆，表达一定的含义

>ping [ip] : 测试和某个主机是否联通
		
* 端口号（port）
>作用：端口是网络地址的一部分，用于区分主机上不同的网络应用程序。

>特点：一个系统中的应用监听端口不能重复

>取值范围： 1 -- 65535
>>1--1023  系统应用或者大众程序监听端口
>>1024--65535 自用端口


## 传输层服务

### 面向连接的传输服务（基于TCP协议的数据传输）

1. 传输特征 ： 提供了可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。
      
2. 实现手段 ： 在通信前需要建立数据连接，通信结束要正常断开连接。

> 三次握手（建立连接）
>>客户端向服务器发送消息报文请求连接
>>服务器收到请求后，回复报文确定可以连接
>>客户端收到回复，发送最终报文连接建立

![](mark_down_img/1_三次握手.png)
					
>四次挥手（断开连接）
>>主动方发送报文请求断开连接
>>被动方收到请求后，立即回复，表示准备断开
>>被动方准备就绪，再次发送报文表示可以断开
>>主动方收到确定，发送最终报文完成断开

![](mark_down_img/1_四次挥手.png)


3. 适用情况 ： 对数据传输准确性有明确要求，传数文件较大，需要确保可靠性的情况。比如：网页获取，文件下载，邮件收发。


### 面向无连接的传输服务（基于UDP协议的数据传输）

1. 传输特点 ： 不保证传输的可靠性，传输过程没有连接和断开，数据收发自由随意。

2. 适用情况 ： 网络较差，对传输可靠性要求不高。比如：网络视频，群聊，广播


***面试要求***
* OSI七层模型介绍一下，tcp/ip模型是什么？
* tcp服务和udp服务有什么区别？
* 三次握手和四次挥手指什么，过程是怎样的？


####tcp/udp 小记
    面试:介绍osi七层模型
    常用协议:tcp协议 udp协议

    面试时遇到擅长的领域着重谈,并可以深入谈,作一些技术描述,往自已做得好的领域引导
    遇到不擅长的领域保持谦逊

    tcp/ip 模型
        三次握手四次挥手(传输层,操作系统控制)
        面向连接
        可靠
    udp 模型
        面向无连接
        不可靠
    ip 域名 端口

    套接字
        流式套接字  tcp协议
        数据报      udp协议




## socket套接字编程

### 套接字介绍

1. 套接字 ： 实现网络编程进行数据传输的一种技术手段

2. Python实现套接字编程：import  socket

3. 套接字分类
>流式套接字(SOCK_STREAM): 以字节流方式传输数据，实现tcp网络传输方案。(面向连接--tcp协议--可靠的--流式套接字)

>数据报套接字(SOCK_DGRAM):以数据报形式传输数据，实现udp网络传输方案。(无连接--udp协议--不可靠--数据报套接字)


### tcp套接字编程

#### 服务端流程

![](mark_down_img/1_TCP_Server.png)
***代码实现：day2/tcp_server.py***

1. 创建套接字

```python
sockfd=socket.socket(socket_family=AF_INET,socket_type=SOCK_STREAM,proto=0)
功能：创建套接字
参数：  socket_family  网络地址类型 AF_INET表示ipv4
	socket_type  套接字类型 SOCK_STREAM(流式)  SOCK_DGRAM(数据报)
	proto  通常为0  选择子协议
返回值： 套接字对象
```
2. 绑定地址

>本地地址 ： 'localhost' , '127.0.0.1'
>网络地址 ： '172.40.91.185'
>自动获取地址： '0.0.0.0'

![](mark_down_img/address.png)

```python
sockfd.bind(addr)
功能： 绑定本机网络地址
参数： 二元元组 (ip,port)  ('0.0.0.0',8888)
```

3. 设置监听

```python
sockfd.listen(n)
功能 ： 将套接字设置为监听套接字，确定监听队列大小
参数 ： 监听队列大小
```
4. 等待处理客户端连接请求

```python
connfd,addr = sockfd.accept()
功能： 阻塞等待处理客户端请求
返回值： connfd  客户端连接套接字
         addr  连接的客户端地址
```
5. 消息收发

```python
data = connfd.recv(buffersize)
功能 : 接受客户端消息
参数 ：每次最多接收消息的大小
返回值： 接收到的内容

n = connfd.send(data)
功能 : 发送消息
参数 ：要发送的内容  bytes格式
返回值： 发送的字节数
```
			
6. 关闭套接字

```python
sockfd.close()
功能：关闭套接字
```

#### 客户端流程

***代码实现：day2/tcp_client.py***

![](mark_down_img/1_TCP_Client.png)
		  
1. 创建套接字
>注意:只有相同类型的套接字才能进行通信
			
2. 请求连接

```python
sockfd.connect(server_addr)
功能：连接服务器
参数：元组  服务器地址
```

3. 收发消息
>注意： 防止两端都阻塞，recv send要配合

4. 关闭套接字


#### tcp 套接字数据传输特点

>* tcp连接中当一端退出，另一端如果阻塞在recv，此时recv会立即返回一个空字串。

>* tcp连接中如果一端已经不存在，失去同步,仍然试图通过send发送则会产生BrokenPipeError
另一种情况是send()一方失去同步,那么试图recv()的一方会收到一个空字符串""


>* 一个监听套接字可以同时连接多个客户端，也能够重复被连接

#### 网络收发缓冲区

1. 网络缓冲区有效的协调了消息的收发速度
2. send和recv实际是向缓冲区发送接收消息，当缓冲区不为空recv就不会阻塞。
	

####tcp服务端流程
            socket - - > bind - - > listen - - > accept(阻塞函数,暂停函数) - -> recv/send  - - > close

    
    创建套接字(对象)
        sockfd = socket.socket(socker_family = AF_INET
        socket_type = SOCK_STREAM,)
        
            参数 family: ipv4(默认) 或 ipv6
            type:   SOCK_STREAM(流式)  SOCK_DGRAM(数据报式) 
        返回值:套接字对象 
    绑定地址 
        bind
        本地地址: localhost 127.0.0.1
        网络地址: 172.xxx.XXX.XXX
        自动获取地址: 0.0.0.0
![绑定地址](mark_down_img/bind.png)
    
    设置监听 
        listen(n)
        将套接字设置为监听套接字,确定监听队列大小
        n--监听队列大小

    等待处理客户端连接请求  
        connfd,addr = accept()
        程序进入阻塞状态,等待处理客户端连接请求,若无请求则一直处于阻塞状态
        connfd 客户端的连接套接字对象   addr 客户端的连接地址(ip)
    
    消息收发  
        data = connfd.recv(buffersize)
        接收客户端消息
        buffersize: 每次最多接收消息的大小
        返回值:接收到的内容

        n = connfd.send(data)
        发送消息
        参数:要发送的内容
        返回值:发送的字节数

    关闭套接字
        socket.close()
        关闭套接字,销毁期间数据
    
####tcp客户端流程 小记
    socket --> connect -->send/recv --> close

    创建套接字

    请求连接
        sockfd.connect(server_addr)
        功能:   连接服务端
        参数:   元组类型(ip,端口号)

    收发消息
        注意,防止两端同时阻塞,recv send 要配合

    关闭套接字


    tcp套接字使用注意事项:
        ·客户端与服务端的socket_type 属性必须相同
        ·socket()默认参数就是tcp套接字  AF_INET,AF_STREAM
        ·客户端connect(x)连接的地址必须与服务端ip相同
        ·send(x)函数的内容必须是字节串,用.encode()函数进行转换
        ·收消息时分段接受,避免内存"爆炸"
        ·断开后另一方recv()返回值为None,程序不再阻塞,之后若强行发送send()两次,抛出管道破裂 broken pipe()错误
        ·接受的字节数小于发送的字节数,分段接收
            网络收发缓冲区:协调收发速度
                如recv(5),一次接收不完,会分多次接受
                粘包
                    网络太慢卡住了,多次发送的消息被一次接受
                    tcp数据是水流式的,没有数据边界

                    粘包坏影响
                    数据如果是各自独立的,粘包会有坏影响,不能把数据区分开来

                    粘包处理
                    降低发送速度
                    在发送的信息中增加消息边界

        两个recv()函数共同在客户端与服务端运行时,两个程序都会陷入阻塞



#### tcp粘包

***代码示例：day2/stick_send.py,stick_recv.py***
	  
>原因：tcp以字节流方式传输，没有消息边界。多次发送的消息被一次接收，此时就会形成粘包。

>影响：如果每次发送内容是一个独立的含义，需要接收端独立解析此时粘包会有影响。

>处理方法
>>1. 人为的添加消息边界
>>2. 控制发送速度


### UDP套接字编程

#### 服务端流程

![](mark_down_img/2_UDP_Server.png)

***代码实现：day2/udp_server.py***
	  
1. 创建数据报套接字
```python
sockfd = socket(AF_INET,SOCK_DGRAM)
```
2. 绑定地址

```python
sockfd.bind(addr)
```

3. 消息收发

```python		    
data,addr = sockfd.recvfrom(buffersize)
功能： 接收UDP消息
参数： 每次最多接收多少字节
返回值： data  接收到的内容
	addr  消息发送方地址

n = sockfd.sendto(data,addr)
功能： 发送UDP消息
参数： data  发送的内容 bytes格式
	addr  目标地址
返回值：发送的字节数
```

4. 关闭套接字
```python
sockfd.close()
```
#### 客户端流程

![](mark_down_img/2_UDP_Client.png)

***代码实现：day2/udp_client.py***

1. 创建套接字
2. 收发消息
3. 关闭套接字



### UDP套接字广播
***代码实现：day3/broadcast_recv.py***
***代码实现：day3/broadcast_recv.py***

udp 套接字广播
    广播地址:一个局域网内最大的地址,向局域网内所有成员发送

* 广播定义 ： 一端发送多点接收
    
* 广播地址 ： 每个网络的最大地址为发送广播的地址，向该地址发送，则网段内所有主机都能接收。



   
   
    udp 套接字编程

        服务端流程
            socket-- > bind -- > recvfrom/sendto -->close()
        创建数据报套接字
            sockfd = socket(AF_NET,SOC_DGRAM)
        绑定地址
            sockfd.bind(addr)
        消息收发
            data , addr = sockfd.recvfrom(buffersize)
            功能:   接收udp主动方套接字信息
            参数:   buffersize 每次接收多少字节
            返回值:   data接收到的内容 addr主动方地址

            n = sockfd.sendto(data,addr)
            功能:   发送udp消息给被动方
            参数:   data 发送的内容,bytes格式
                    addr 发送给被动方的地址
            返回值:    发送的字节数

        客户端流程
            socket -- > sendto/recvfrom - - > close
            ·创建套接字
            ·收发消息
            ·关闭套接字


####tcp与udp套接字小记
    tcp使用案例:最典型的http传输用tcp,聊天室,ftp文件传输,查找(单词)反馈
    udp使用案例:广播,互联网直播
>   每个tcp连接都是1对1连接,这意味着每个连接都需要一个套接字socket,并且需要随时测试是否数据可读可写.当连接数量达到一定的程度,性能会直线下降. 
    面对小数据量海量长时间连接的应用时,选择tcp必须要慎重再慎重

---------------
>总结 ：tcp套接字和udp套接字编程区别
>>1. 流式套接字是以字节流方式传输数据，数据报套接字以数据报形式传输
>>2. tcp套接字会有粘包，udp套接字有消息边界不会粘包
>>3. tcp套接字保证消息的完整性，udp套接字则不能
>>4. tcp套接字依赖listen accept建立连接才能收发消息，udp套接字则不需要
>>5. tcp套接字使用send，recv收发消息，udp套接字使用sendto，recvfrom
---------------------  
  
#####面向连接与面向无连接    
######面向连接
* 面向连接，是指通信双方在进行通信之前，要事先在双方之间建立起一个完整的可以彼此沟通的通道，这个通道也就是连接。
>
* 在通信过程中，整个连接的情况一直可以被实时地监控和管理。而无连接的通信，就不需要预先建立起一个联络两个通信节点的连接来，需要通信的时候，发送节点就可以往“网络”上送出信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控，让该信息的传递在通信网络中尽力而为地往目的地节点传送。

>
* 面向连接的协议比面向无连接的协议在可靠性上有着显著的优势，但建立连接前必须等待接收方响应，传输信息过程中必须确认信息是否传到，断开连接时需要发出响应信号等，无形中加大了面向连接协议的资源开销。

>
* UDP数据报比TCP小许多，这意味着更小的负载和更有效的使用带宽。许多即时聊天软件采用UDP协议，与此有莫大的关系。
>
* 两种协议的特点决定了它们的应用场景，在网络中，有些服务，如HTTP、FTP等，对数据的可靠性要求较高，在使用这些服务时，必须保证数据包能够完整无误的送达;而另外一些服务，如弹幕、即时聊天工具等，并不需要这么高的可靠性，高效率和实时性才是它们所关心的。



--------------------- 
#####两种套接字的区别
    udp 负载小,效率高  tcp传输更可靠

    tcp套接字以字节流方式传输数据,udp套接字以数据报方式传输
    tcp套接字会有粘包,udp套接字会有丢包
    tcp套接字能保证消息的完整性
    tcp套接字以来listen accept建立连接才能收发消息,udp套接字则不需要
    tcp套接字使用send,recv函数收发消息,udp套接字使用sendto,recvfrom
    

#####套接字属性
    socket.family() 地址类型
    socket.type()   套接字类型
    socket.getsockname() 获取bind绑定的地址 
        返回元组 (" ",端口)
    socket.fileno()  文件描述符(IO标识)
        通常为从0开始顺次递增
        一般0,1,2都被系统占用了
    socket.getpeername() 获取连接端地址 
        必须有连接套接字,否则报错
        结果同accept返回的addr
    socket.setsockopt(level,option,value) 设置套接字选项
        level: 套接字的SOL,IPPROTO等属性 SOL_SOCKET
            socket.setsocketopt(SOL_SOCKET,SO_REUSEADDR,1) 设置端口可以立刻被重用   (socekt)是对象,用对象去点它
            
        option: TCP等属性
    


### socket套接字属性

***代码实现：day2/sock_attr.py***

【1】 sockfd.type  套接字类型

【2】 sockfd.family 套接字地址类型

【3】 sockfd.getsockname() 获取套接字绑定地址

【4】 sockfd.fileno() 获取套接字的文件描述符

【5】 sockfd.getpeername() 获取连接套接字客户端地址

【6】 sockfd.setsockopt(level,option,value)
		功能：设置套接字选项
		参数： level  选项类别   SOL_SOCKET
			option 具体选项内容
			value  选项值

【7】 sockfd.getsockopt(level,option) 
		功能 ： 获取套接字选项值

![](mark_down_img/2_setsockopt.png)




### TCP套接字之HTTP传输

#### HTTP协议 （超文本传输协议）

1. 用途 ： 网页获取，数据的传输

2. 特点
>* 应用层协议，传输层使用tcp传输
>* 简单，灵活，很多语言都有HTTP专门接口
>* 无状态，协议不记录传输内容
>* http1.1 支持持久连接，丰富了请求类型

3. 网页请求过程

>1.客户端（浏览器）通过tcp传输，发送http请求给服务端
>2.服务端接收到http请求后进行解析
>3.服务端处理请求内容，组织响应内容
>4.服务端将响应内容以http响应格式发送给浏览器
>5.浏览器接收到响应内容，解析展示

![](mark_down_img/2_网站访问.png)
    
#### HTTP请求（request）

***代码实现：day3/http_test.py***
***代码实现：day3/http_server.py***

* 请求行 ： 具体的请求类别和请求内容

```
	GET         /        HTTP/1.1
	请求类别   请求内容     协议版本
```

请求类别：每个请求类别表示要做不同的事情 

```		
		GET : 获取网络资源
		POST ：提交一定的信息，得到反馈
		HEAD ： 只获取网络资源的响应头
		PUT ： 更新服务器资源
		DELETE ： 删除服务器资源
		CONNECT
		TRACE ： 测试
		OPTIONS ： 获取服务器性能信息
```

* 请求头：对请求的进一步解释和描述
```
Accept-Encoding: gzip
```
* 空行
* 请求体: 请求参数或者提交内容

#### http响应（response）

1. 响应格式：响应行，响应头，空行，响应体

* 响应行 ： 反馈基本的响应情况

```	    
HTTP/1.1     200       OK
版本信息    响应码   附加信息
```

响应码 ： 
```
1xx  提示信息，表示请求被接收
2xx  响应成功
3xx  响应需要进一步操作，重定向
4xx  客户端错误
5xx  服务器错误
```
* 响应头：对响应内容的描述
```		    
Content-Type: text/html
```

* 响应体：响应的主体内容信息 
    http协议(超文本传输协议)
![http请求与响应](mark_down_img/http.png)

        本身是应用层协议,而且必须选用TCP(传输层、流式)套接字
        用于网页获取,数据传输
        稳定性好,1.0版本和1.1版本都用了很多年
        1.1支持持久连接
    ·网页的请求过程  IP地址:端口号
        ·请求行     表达主要的请求类型的请求内容
                   格式:    GET/HTTP/1.1
        
        ·请求头     对请求做一些描述,键值对   key:value\r\n

        ·空行

        ·请求体
                   内容和一些参数
        
        一次网页的打开伴随多次http请求与相应
        网页请求类别:
            get
            post
            head
            put
            delete

            connect
            trace
            options
    
    http响应
        ·响应码分类
            1xx     提示,表示请求被接收(常见于后端)
            2xx     响应成功
            3xx     响应需要进一步处理
            4xx     客户端错误  例如404
            5xx     服务器错误

        响应格式

            响应行
                HTTP/1.1   200    OK
                版本信息    响应码   附加信息
            响应头
                对响应行做一些描述,键值对格式
            空行

            响应体
                给客户端的一些数据
                内容和一些参数

####http协议小记
    http协议本质就是通过send()函数发送的内容"规定标准的格式",使接收方能够方便的解析内容



## struct模块的使用

***代码实现：day3/struct_recv.py***
***代码实现：day3/struct_send.py***
####Stuct小记
    作用是将不同格式的数据元组打包成类c格式数据的元组,接收端可以方便地解析数据
    解决传输过程中的粘包问题,而且能传输类c的int,char基本数据.

1. 原理： 将一组简单数据进行打包，转换为bytes格式发送。或者将一组bytes格式数据，进行解析。

2. 接口使用

```python
Struct(fmt)
功能: 生成结构化对象
参数：fmt  定制的数据结构

st.pack(v1,v2,v3....)
功能: 将一组数据按照指定格式打包转换为bytes
参数：要打包的数据
返回值： bytes字节串

st.unpack(bytes_data)
功能： 将bytes字节串按照指定的格式解析
参数： 要解析的字节串
返回值： 解析后的内容

struct.pack(fmt,v1,v2,v3...)
struct.unpack(fmt,bytes_data)
```
>说明： 可以使用struct模块直接调用pack unpack。此时这两函数第一个参数传入fmt。其他用法功能相同

 
   
    Struct
        原理
           将一组简单数据进行打包,转为byte格式发送.
           或者将一组byte格式数据,进行解析 
        格式化网络传输数据
        将字节串、整形、浮点型 数据打包成类C的数据模式

        接口使用:
            PassPass
![使用struct函数进行打包,C与Python数据格式转换表](mark_down_img/struct_format.png)

    Struct
        声明待解析的数据格式
        若数据数量不够往后凑0,数据超出截掉一部分
        传输端与客户端的格式必须相同(事先规定协议)


        st.pack
            将一组数据按指定格式打包转换为bytes
            一般在传输端进行打包,再发送给客户端

        st.unpack
            一般在接受端进行接收
            解析后的内容为按format格式的元组

        可以使用struct.pack or struct.unpack 进行打包和解析,不用创建对象,但fmt格式必须相同,否则报错

>------------------------------------------




#并发编程
    多任务:在一个程序当中同时进行多个任务,利用并发和并行,提高计算机运行效率
    实现方案:多进程、多线程
    并发执行:同时处理多个任务,内核在任务间不断的被切换
            对于计算密集型程序,提升效率不明显
            对于IO密集型程序,并发能够提升程序的效率
    并行:   多个任务在利用多核资源同时执行

    ·程序与进程
        程序就是一个文件,静态的
        进程就是执行程序的过程,动态的,占用一定计算机资源,程序执行完毕进程结束

###·进程有什么状态

    ·进程状态
        三态与五态
![http请求与响应](mark_down_img/three_state.png)
![http请求与响应](mark_down_img/five_state.png)

    ·进程的特征
        进程可以使用计算机多核资源
        进程是计算机分配资源的最小单位
        进程之间的运行互不影响
            父进程与子进程各自独立
        每个进程拥有独立空间,各自使用自己空间资源
    
    ·fork   pid = fork()
        功能: 请求操作系统创建新的进程
        返回值:整数,如果创建进程失败返回一个负数,如果成功则在原有进程中返回新进程的PID,在新进程中返回0
        子进程复制父进程的内容,在内存中重新开辟空间
        if结构是创建fork进程的固定搭配
        (孤儿进程)特殊情况:在pycharm中,若父进程先执行完,子进程若未执行,子进程会丢失终端

    os.getpid()
        功能: 获取一个进程的PID值
        返回值: 返回当前进程的PID
    os.getppid()
        功能: 获取父进程的PID号
        返回值: 返回父进程PID
    os._exit(status)
        功能: 结束一个进程
        参数:进程的终止状态
            exit_code没有特定含义,默认为0
    sys.exit([status])
        功能:退出进程
        参数:整数 表示退出状态
            字符串 表示退出时打印内容
    注:父进程、子进程退出不会影响对方继续执行
####关于sys.exit与os._exit方法的区别
    python的程序有两中退出方式：os._exit()， sys.exit()。

>os._exit()会直接将python程序终止，之后的所有代码都不会继续执行。

>sys.exit()会引发一个异常：SystemExit，如果这个异常没有被捕获，那么python解释器将会退出。如果有捕获此异常的代码，那么这些代码还是会执行。捕获这个异常可以做一些额外的清理工作。0为正常退出，其他数值（1-127）为不正常，可抛异常事件供捕获。

>os._exit和sys.exit的区别:  sys.exit()的退出比较优雅，调用后会引发SystemExit异常，可以捕获此异常做清理工作。os._exit()直接将python解释器退出，余下的语句不会执行。

>一般来说os._exit() 用于在线程中退出 
sys.exit() 用于在主线程中退出。

>exit(0)和exit(1)
exit(0)：无错误退出 
exit(1)：有错误退出 

####孤儿进程与僵尸进程
    孤儿进程 : 父进程先于子进程退出,此时子进程成为孤儿进程。
        孤儿进程会被系统进程收养,此时系统进程就会成为孤儿进程新的父进程,孤儿进程退出
    该进程会自动处理。

    僵尸进程:子进程先于父进程退出,父进程没有处理子进程的退出状态
            孤儿进程退出时不会成为僵尸进程
            僵尸进程占用内存,必须清理

#####处理僵尸进程的方法        
        方法一:os.wait()处理僵尸进程,即"阻塞父进程"等待子进程结束后再运行父进程(效率低)
        
        方法二:创建二级子进程,使其成为孤儿进程,一级子进程用os.wait()销毁

        方法三:使用signal模块在父进程创建子进程前写如下语句 :
            import signal
            signal.signal(signal.SIGCHLD,signal.SIG_IGN)
            特点 : 非阻塞,不会影响父进程运行。可以处理所有子进程退出


####day 8  聊天室项目
思路分析方法

    1. 需求分析  干什么达到什么效果
    
    2. 技术分析
        * 数据如何流动
            转发 :  客户端 --> 服务端 --> 其它客户端

        * 网络模型如何构建
            tcp、udp协议都可,tcp协议较为复杂,故构建udp数据传输

        * 用户信息在哪儿维护如何维护
            数据的处理 逻辑 存储 在服务端
            缓存和高频使用的特殊数据在客户端存储

            服务端 : {name:address}字典键不重复
                    [(name,address),] 列表for i,j in listXX:
                                    使用比较广泛

        * 随意收发消息如何避免阻塞
            收发分别使用不同的进程执行,一个发送进程,一个接受进程
    
    3.结构设计注意事项
        * 采用什么封装结构  :  函数
        * 编写一个功能测试一个功能
        * 注意注释和结构的设计
    
    4. 分析功能模块
        * 网络搭建
        * 进入聊天室
            客户端 : * 输入姓名
                    * 将请求发送给服务器
                    * 接收结果
                    * 允许进入则可以聊天,不允许则重新输入姓名


            服务端 : * 接收请求
                    * 判断是否存在用户名
                    * 如果允许进入则将用户存储,通知其他客户端
                    * 如果不允许则结束
                    * 将结果通知客户端



        * 聊天
            客户端 : * 创建新的进程
                    * 一个进程循环发送消息
                    * 一个进程循环接受消息

            服务端 : * 接受请求
                    * 判断请求类型
                    * 将消息转发给其他人

        * 退出聊天室
            客户端: * 输入quit或者ctrl-c退出
                   * 将请求发送给客户端
                   * 结束进程

            服务端: * 接收请求
                   * 将退出消息告知其他人
                   * 给该用户发送EXIT
                   * 删除用户



        * 管理员消息

    5.通信协议设置
        发送的消息附加一个属性,让服务端分开处理信息
        例如 "L Alice",用空格分开,让服务器好解析

        * 进入聊天室 : L
        * 聊天 : C
        * 退出 : Q
        * 服务器反馈 : OK成功  其他表示失败
        * 客户端收到 EXIT 退出进程

####multiprocessing 模块创建进程
    Process()创建进程对象
    start()启动进程
    join()回收进程

    编写进程函数
    生成进程对象
    启动进程
    回收进程

        演示:process_test01.py
    在实际开发中,父进程只负责创建多个子进程,具体功能由不同的子进程实现

    函数在传参时,各种传参方法可以搭配使用,例如:
        def fun01(a, b):
            pass

        fun01(1, 2)
        fun01(*(1, 2))
        fun01(*{"a": 1, "b": 2})
        fun01(*(2,), b=2)
        fun01(*(2,), *{"b": 9})

    注意
        使用multiprocessing创建进程同样是子进程复制父进程空间代码段,父子进程运行互不
        影响。
        子进程只运行target绑定的函数部分,其余内容均是父进程执行内容。
        multiprocessing中父进程往往只用来创建子进程回收子进程,具体事件由子进程完成。
        multiprocessing创建的子进程中无法使用标准输入
    
     进程对象属性
        代码示例: day2/process_attr.py
        p.name  进程名称
        p.pid   对应子进程的PID号
        p.is_alive()    查看子进程是否在生命周期
        p.daemon    设置父子进程的退出关系

        如果设置为True则子进程会随父进程的退出而结束
        要求必须在start()前设置
        如果daemon设置成True 通常就不会使用 join()


###进程池实现
>    应用    
    在爬虫中应用较多
    进程反复被创建和销毁,浪费计算机资源
    使用进程池技术,让进程能够被复用,进程结束后不会被销毁

    池:一系列元素的集合

        必要性
            进程的创建和销毁过程消耗的资源较多
            当任务量众多,每个任务在很短时间内完成时,需要频繁的创建和销毁进程。此时对计算机压力较大
            
            进程池技术很好的解决了以上问题。

        原理
            创建一定数量的进程来处理事件,事件处理完进 程不退出而是继续处理其他事件,直到所有事件

            全都处理完毕统一销毁。增加进程的重复利用,降低资源消耗。

        关闭进程池后,队列中的进程会正常被池中进程处理


####进程池创建
        创建进程池对象,放入适当的进程
            from multiprocessing import Pool
            Pool(processes)
            功能: 创建进程池对象
            参数: 指定进程数量,默认根据系统自动判定
        将事件加入进程池队列执行
            pool.apply_async(func,args,kwds)
            功能: 使用进程池执行 func事件
            参数: func 事件函数
            args 元组 给func按位置传参
            kwds 字典 给func按照键值传参
            返回值: 返回函数事件对象
        关闭进程池
            pool.close()
            功能: 关闭进程池
        回收进程池中进程
            pool.join()
            功能: 回收进程池中进程


###进程间通信(IPC)
必要性: 进程间空间独立,资源不共享,此时在需要进程间数据传输时就需要特定的手段进行数据通信。
>>两个不相关的进程间通信,常用socket  第三方rabbitmq


####常用进程间通信方法
    利用第三方介质进行数据传输,例如网络或者文件
    管道 消息队列 共享内存 信号 信号量 套接字
####如何选择通信方法
*    pipe通信是实时的,recv是阻塞的,多次send类似队列
*    quene是独立存储的,非阻塞的,put一次,get一次,之前内容不会被覆盖
*    共享内存也是独立存储的,每次写入内容会覆盖之前内容
*    信号灯集靠信号1,2,3,4代表的意义进行通信
#####  管道通信
    通信原理
        在内存中开辟管道空间,生成管道操作对象,多个进程使用同一个管道对象进行读写即可实现通信
    实现方法
        from
        multiprocessing import Pipe
        fd1,fd2 = Pipe(duplex = True)
            功能: 创建管道
            参数:默认表示双向管道
            如果为False 表示单向管道
            返回值:表示管道两端的读写对象
            如果是双向管道均可读写
            如果是单向管道fd1只读 fd2只写
        fd.recv()
            功能 : 从管道获取内容
            返回值:获取到的数据
        fd.send(data)
            功能: 向管道写入内容
            参数: 要写入的数据,整数,列表,元组等

    注意:
        如果没有消息可接收，recv方法会一直阻塞。
        若管道关闭,使用send()或recv()会抛出异常 OSError: handle is closed
        multiprocessing 中管道通信只能用于有亲缘关系的进程中
        管道通信只能在父进程中创建,子进程必须通过父进程获取
    
    
####消息队列
    代码示例: day2/queue_0.py
    通信原理
    在内存中建立队列模型,进程通过队列将消息存入,或者从队列取出完成进程间通信。

    实现方法
        q = Queue(maxsize=0)
            功能: 创建队列对象
            参数:最多存放消息个数
        返回值:队列对象
        q.put(data,[block,timeout])
            功能:向队列存入消息
            参数:data 要存入的内容
            block 设置是否阻塞 False为非阻塞
            timeout 超时检测
        q.get([block,timeout])
            功能:从队列取出消息
            参数:block 设置是否阻塞 False为非阻塞
            timeout 超时检测
            返回值: 返回获取到的内容
        q.full() 判断队列是否为满
        q.empty()  判断队列是否为空
        q.qsize()  获取队列中消息个数
        q.close()  关闭队列
        
####共享内存
    通信原理:在内存中开辟一块空间,进程可以写入内容和读取内容完成通信,但是每次写入内容会覆盖之前内容。
    
    实现方法
        from multiprocessing import Value,Array
* obj = Value(ctype,data)
>        功能 : 开辟共享内存
>        参数 : ctype 表示共享内存空间类型 'i' 'f'  'c'
>              data    共享内存空间初始数据
>                返回值:共享内存对象
>        obj.value  对该属性的修改查看即对共享内存读写

* obj = Array(ctype,data)
>        功能: 开辟共享内存空间
>       参数: ctype 表示共享内存数据类型,定义的类型若为整形,则data的类型必须全为整形
>            data  整数则表示开辟空间的大小,
>            shm_ex = Array("i", 5)   # 实际意义为shm_ex = [0,0,0,0,0]
>
>            其他数据类型表示开辟空间存放的初始化数据
>        返回值:共享内存对象
>------------------------------------
>        Array共享内存读写: 通过遍历obj可以得到每个值,直接可以通过索引序号修改任意值。
>        * 可以使用obj.value直接打印共享内存中的字节串  
>       for i in shm:
>          print(i)
>          shm[1] = 233  #或者这届用索引修改值


![http请求与响应](mark_down_img/shared_memory.png)


####信号量(信号灯集)
    代码示例: day2/sem.py
    应用:
            
            很多个进程同时执行时,控制任务最大同时执行数

    通信原理
    给定一个数量对多个进程可见。多个进程都可以操作该数量增减,并根据数量值决定自己的行
    为。


    实现方法
    from multiprocessing import Semaphore
    sem = Semaphore(num)
        功能 : 创建信号量对象
        参数 : 信号量的初始值
        返回值 : 信号量对象
    sem.acquire() 将信号量减1 当信号量为0时阻塞
    sem.release() 将信号量加1
    sem.get_value() 获取信号量数量


## 线程编程（Thread）

### 线程基本概念

1. 什么是线程
【1】 线程被称为轻量级的进程
【2】 线程也可以使用计算机多核资源，是多任务编程方式
【3】 线程是系统分配内核的最小单元  
【4】 线程可以理解为进程的分支任务

>进程是分配资源的最小单元,线程是比进程更小的运行单元,一个进程至少有一个线程

>当一个进程启动之后，会默认产生一个主线程，因为线程是程序执行的最小单位，当设置多线程时，主线程会创建多个子线程
在Python中，默认情况下就是setDaemon(False)，主线程执行完自己的任务以后，就退出了，此时子线程会继续执行自己的任务，直到自己的任务结束




####线程的操作指南
>>>>应用:把一个函数提取出来成为线程,使其独立运行
使用:创建Tread()对象,该对象的"target= "属性为提取出的方法名
若提取出的方法需要传参,在创建对象时把传参一并完成
Tread()对象的一些属性
Name属性,默认为Thread - 1
    通过setName()修改
    通过getName()获取
Daemon属性,默认为False
    为True时,主线程退出分支线程也退出
    为False时,两者互不影响


>>>>自定义线程类(含有多种参数的情况)
作用:根据需求,在原有线程类的基础上自定义添加线程对象的实例方法
    当一个线程需要有很多步骤,或者需要在线程内添加方法时,使用自定义线程可以时线程的逻辑清晰,增加代码可读性
做法:在self.run()方法中调用所有要执行的方法


>>>实现多个线程之间的通信,就使用全局变量
但要防止共享资源的无序争夺,共享资源被有序存取
    做法:全局变量可能被多个线程使用,用Event()对象的 set() 和 wait()(阻塞) 实现线程的同步互斥
>>>>thread_lock.py
使用Lock()对象的 .acquire() 和 .release()  方法实现线程的同步互斥





2. 线程特征
【1】 一个进程中可以包含多个线程,也可以只有一个线程
【2】 线程也是一个运行行为，消耗计算机资源
【3】 一个进程中的所有线程共享这个进程的资源
【4】 多个线程之间的运行互不影响各自运行
【5】 线程的创建和销毁消耗资源远小于进程  约二十分之一
【6】 各个线程也有自己的ID等特征


### threading模块创建线程

***代码示例：day3/thread1.py***
***代码示例：day3/thread2.py***

【1】 创建线程对象

```	  
from threading import Thread 

t = Thread()
功能：创建线程对象
参数：target 绑定线程函数
     args   元组 给线程函数位置传参
     kwargs 字典 给线程函数键值传参
```

【2】 启动线程

```
 t.start()
```

【3】 回收线程

```
 t.join([timeout])
```

### 线程对象属性

***代码示例：day3/thread_attr.py***

>t.name 线程名称
>t.setName()  设置线程名称
>t.getName()  获取线程名称

>t.is_alive()  查看线程是否在生命周期

>t.daemon  设置主线程和分支线程的退出关系
>t.setDaemon()  设置daemon属性值
>t.isDaemon()  查看daemon属性值
>
>>daemon为True时主线程退出分支线程也退出。要在start前设置，通常不和join一起使用。


### 自定义线程类

***代码示例：day3/myThread.py***

1. 创建步骤
【1】 继承Thread类
【2】 重写__init__方法添加自己的属性，使用super加载父类属性
【3】 重写run方法

2. 使用方法
【1】 实例化对象
【2】 调用start自动执行run方法
【3】 调用join回收线程


## 同步互斥

### 线程间通信方法

1. 通信方法
>线程间使用全局变量进行通信


2. 共享资源争夺

* 共享资源：多个进程或者线程都可以操作的资源称为共享资源。对共享资源的操作代码段称为临界区。

* 影响 ： 对共享资源的无序操作可能会带来数据的混乱，或者操作错误。此时往往需要同步互斥机制协调操作顺序。
	
3. 同步互斥机制

>同步 ： 同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，按照必要的步骤有序执行操作。

![](mark_down_img/7_同步.png)

>互斥 ： 互斥是一种制约关系，当一个进程或者线程占有资源时会进行加锁处理，此时其他进程线程就无法操作该资源，直到解锁后才能操作。


![](mark_down_img/7_互斥.png)

### 线程同步互斥方法

#### 线程Event
>>应用:防止共享资源的无序争夺,共享资源被有序存取
***代码示例：day3/thread_event.py***

```python		  
from threading import Event

e = Event()  创建线程event对象

e.wait([timeout])  阻塞等待e被set  超时返回False,没超时返回True

e.set()  设置e，使wait结束阻塞
e.clear() 使e回到未被设置状态

e.is_set()  查看当前e是否被设置
```

#### 线程锁 Lock

***代码示例：day3/thread_event.py***

```python
from  threading import Lock

lock = Lock()  创建锁对象
lock.acquire() 上锁  如果lock已经上锁再调用会阻塞
lock.release() 解锁

with  lock:  上锁
...
...
	 with代码块结束自动解锁
```

### 死锁及其处理

1. 定义
>死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。

![](mark_down_img/死锁.jpg)

2. 死锁产生条件

***代码示例: day3/dead_lock.py***

>死锁发生的必要条件
>>* 互斥条件：指线程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
>>* 请求和保持条件：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求线程阻塞，但又对自己已获得的其它资源保持不放。
>>* 不剥夺条件：指线程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放,通常CPU内存资源是可以被系统强行调配剥夺的。
>>* 环路等待条件：指在发生死锁时，必然存在一个线程——资源的环形链，即进程集合{T0，T1，T2，···，Tn}中的T0正在等待一个T1占用的资源；T1正在等待T2占用的资源，……，Tn正在等待已被T0占用的资源。

>死锁的产生原因
>>简单来说造成死锁的原因可以概括成三句话：
>>* 当前线程拥有其他线程需要的资源
>>* 当前线程等待其他线程已拥有的资源
>>* 都不放弃自己拥有的资源

3. 如何避免死锁

死锁是我们非常不愿意看到的一种现象，我们要尽可能避免死锁的情况发生。通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率。

## python线程GIL

1. python线程的GIL问题 （全局解释器锁）

>什么是GIL ：由于python解释器设计中加入了解释器锁，导致python解释器同一时刻只能解释执行一个线程，大大降低了线程的执行效率。

>>若取消GIL,会影响利用第三方库等依赖于GIL的代码,解决这个问题不亚于重写一门开发语言.

>>给解释器加锁,在解释线程时,同一时刻只能解释一个线程.导致python效率低

>导致后果： 因为遇到阻塞时线程会主动让出解释器，去解释其他线程。所以python多线程在执行多阻塞高延迟IO时可以提升程序效率，其他情况并不能对效率有所提升。

>GIL问题建议
>* 尽量使用进程完成无阻塞的并发行为
>* 不使用c作为解释器 （使用 Java  C#）

2. 结论 ： 在无阻塞状态下，多线程程序和单线程程序执行效率几乎差不多，甚至还不如单线程效率。但是多进程运行相同内容却可以有明显的效率提升。

## 进程与线程的区别联系
####关于Python 多线程为何适合IO密集型任务
io多线程优点  节约资源???
>io密集型任务，一般情况下，io有发送数据（output）和返回数据（input）两个过程。就是发送消息，等待返回消息。python多线程在处理io的时候，一个线程获得GIL发送消息，然后等待返回消息（阻塞），python此时释放GIL, 其他线程得到GIL发送消息，然后同样等待返回消息（阻塞）......，这样保证了IO传输过程时间的合理利用，提高io传输效率。

>由于python在用cpu执行计算任务的时候，GIL锁不会被释放，python多线程其实还是使用的单核在进行cpu计算。一个cpu时间片只会分给一个线程，因此，cpu密集型的情况下，多线程并不会加快计算速度。

>但是多核下，多核多线程比单核单线程更差，原因是单核下多线程，每次释放GIL唤醒的那个线程都能获得GIL锁，能够无缝执行，但多核下，CPU释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能被CPU0拿到，导致其他几个CPU上被唤醒的线程会醒着等待到切换时间后又进入待调度状态，这样会造成[线程颠簸]，导致效率更低。

### 区别联系
1. 两者都是多任务编程方式，都能使用计算机多核资源
2. 进程的创建删除消耗的计算机资源比线程多
3. 进程空间独立，数据互不干扰，有专门通信方法；线程使用全局变量通信
4. 一个进程可以有多个分支线程，两者有包含关系
5. 多个线程共享进程资源，在共享资源操作时往往需要同步互斥处理
6. 进程线程在系统中都有自己的特有属性标志，如ID,代码段，命令集等。

### 使用场景

1. 任务场景：如果是相对独立的任务模块，可能使用多进程，如果是多个分支共同形成一个整体任务可能用多线程

2. 项目结构：多种编程语言实现不同任务模块，可能是多进程，或者前后端分离应该各自为一个进程。

3. 难易程度：通信难度，数据处理的复杂度来判断用进程间通信还是同步互斥方法。


### 要求
1. 对进程线程怎么理解/说说进程线程的差异
2. 进程间通信知道哪些，有什么特点
3. 什么是同步互斥，你什么情况下使用，怎么用
4. 给一个情形，说说用进程还是线程，为什么
5. 问一些概念，僵尸进程的处理，GIL问题，进程状态


## 并发网络通信模型

### 常见模型分类

1. 循环服务器模型 ：循环接收客户端请求，处理请求。同一时刻只能处理一个请求，处理完毕后再处理下一个。

	>优点：实现简单，占用资源少
	>缺点：无法同时处理多个客户端请求

	>适用情况：处理的任务可以很快完成，客户端无需长期占用服务端程序。udp比tcp更适合循环。

2. IO并发模型：利用IO多路复用,异步IO等技术，同时处理多个客户端IO请求。
    >>网络本身就是个IO模型

	>优点 ： 资源消耗少，能同时高效处理多个IO行为
	>缺点 ： 只能处理并发产生的IO事件，无法处理cpu计算

	>适用情况：HTTP请求，网络传输等都是IO行为。
	
3. 多进程/线程网络并发模型：每当一个客户端连接服务器，就创建一个新的进程/线程为该客户端服务，客户端退出时再销毁该进程/线程。

	>优点：能同时满足多个客户端长期占有服务端需求，可以处理各种请求。
	>缺点： 资源消耗较大

	>适用情况：客户端同时连接量较少，需要处理行为较复杂情况。


### 基于fork的多进程网络并发模型

***代码实现: day4/fork_server.py***

#### 实现步骤

1. 创建监听套接字
2. 等待接收客户端请求
3. 客户端连接创建新的进程处理客户端请求
4. 原进程继续等待其他客户端连接
5. 如果客户端退出，则销毁对应的进程

### 基于threading的多线程网络并发

***代码实现: day4/thread_server.py***

#### 实现步骤

1. 创建监听套接字
2. 循环接收客户端连接请求
3. 当有新的客户端连接创建线程处理客户端请求
4. 主线程继续等待其他客户端连接
5. 当客户端退出，则对应分支线程退出


### ftp 文件服务器

***代码实现: day5/ftp***

1. 功能 
	【1】 分为服务端和客户端，要求可以有多个客户端同时操作。
	【2】 客户端可以查看服务器文件库中有什么文件。
	【3】 客户端可以从文件库中下载文件到本地。
	【4】 客户端可以上传一个本地文件到文件库。
	【5】 使用print在客户端打印命令输入提示，引导操作



## IO并发

### IO 分类

>IO分类：阻塞IO ，非阻塞IO，IO多路复用，异步IO等


#### 阻塞IO 

1.定义：在执行IO操作时如果执行条件不满足则阻塞。阻塞IO是IO的默认形态。

>> 阻塞IO逻辑简单,但效率低

2.效率：阻塞IO是效率很低的一种IO。但是由于逻辑简单所以是默认IO行为。

3.阻塞情况：
* 因为某种执行条件没有满足造成的函数阻塞
e.g.  accept   input   recv

* 处理IO的时间较长产生的阻塞状态
e.g. 网络传输，大文件读写
			

####　非阻塞IO

1. 定义 ：通过修改IO属性行为，使原本阻塞的IO变为非阻塞的状态。

* 设置套接字为非阻塞IO

 >sockfd.setblocking(bool)
 功能：设置套接字为非阻塞IO
 参数：默认为True，表示套接字IO阻塞；设置为False则套接字IO变为非阻塞

* 超时检测 ：设置一个最长阻塞时间，超过该时间后则不再阻塞等待。

	>sockfd.settimeout(se+c)
	功能：设置套接字的超时时间
	参数：设置的时间

### IO多路复用 
1. 定义
>同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件。以此形成可以同时处理多个IO的行为，避免一个IO阻塞造成其他IO均无法执行，提高了IO执行效率。



######poll 与 select 的原理 
    原理涉及到应用层与系统层之间进行交互

        整体拷贝至系统内核 -- > 经过处理 -- > 内核整体反馈 --> 应用层进行遍历
    epoll 的原理
        单独拷贝监听的对象 --- > 处理 -- > 反馈
        由于减少了一次遍历过程,所以epoll的效率更高

    所以只有epoll不允许连续两次register()同一个文件标识符file-no相同的对象

    水平触发:io就绪时,如一个accept()被触发,如不处理,会一直处于被触发状态
    边缘触发:条件同上,只触发一次

2. 具体方案

>select方法 ： windows  linux  unix
>poll方法： linux  unix
>epoll方法： linux

select 优点 : 支持  windows  linux  unix
       缺点 : 效率相对epoll一般,最多监控1024个IO

poll   优点 : 支持监控更多IO,支持linux Unix
       缺点 : 效率相对epoll一般

epoll  优点 : 效率高,有更多的触发方式
       缺点 : 只支持Linux

#### select 方法

***代码实现: day5/select_server.py***

```python
rs, ws, xs=select(rlist, wlist, xlist[, timeout])
>> 自身也是一个阻塞函数,所有监控对象有就绪的就会结束阻塞,或者等待设置的timeout参数,就结束阻塞
>> 阻塞结束时返回所有处于就绪状态的IO对象

>> 读事件,写事件,异常事件
>> 三个参数列表代表在IO对象身上可能发生的任何事情

IO读事件:需要等待发生的,不是能主动控制的,例如等待客户端连接
IO写事件:可以主动处理的,例如文件的读写,发消息
一个IO对象可能IO对象可能同时有读事件和写事件,例如connect


功能: 监控IO事件，阻塞等待IO发生
参数：rlist  列表  存放关注的等待发生的IO事件 
      wlist  列表  存放关注的要主动处理的IO事件
      xlist  列表  存放关注的出现异常要处理的IO
      timeout  超时时间

返回值： rs 列表  rlist中准备就绪的IO
        ws 列表  wlist中准备就绪的IO
	xs 列表  xlist中准备就绪的IO
```

select 实现tcp服务

	【1】 将关注的IO放入对应的监控类别列表
	【2】通过select函数进行监控
	【3】遍历select返回值列表，确定就绪IO事件
	【4】处理发生的IO事件

>注意
>>wlist中如果存在IO事件，则select立即返回给ws
>>处理IO过程中不要出现死循环占有服务端的情况
>>IO多路复用消耗资源较少，效率较高

------------
###@@扩展: 位运算

定义 ： 将整数转换为二进制，按二进制位进行运算

运算符号： 
>		&  按位与
>		|  按位或
>		^  按位异或
>		<< 左移
>		>> 右移

```python
e.g.  14 --> 01110
      19 --> 10011

14 & 19 = 00010 = 2  一0则0    按位与,用于检查属性

14 | 19 = 11111 = 31 一1则1    按位或,用于添加属性
14 ^ 19 = 11101 = 29 相同为0不同为1
14 << 2 = 111000 = 56 向左移动低位补0  左移一位相当于10进制乘以2
14 >> 2 = 11 = 3  向右移动去掉低位      右移一位相当于地板除以2
        应用: 判断属性(flag)
```
----------------


#### poll方法

***代码实现: day5/poll_server.py***

```python
p = select.poll()
功能 ： 创建poll对象
返回值： poll对象
```


```python	
p.register(fd,event)   
功能: 注册关注的IO事件
参数：fd  要关注的IO
      event  要关注的IO事件类型
  	     常用类型：POLLIN  读IO事件（rlist）
		      POLLOUT 写IO事件 (wlist)
		      POLLERR 异常IO  （xlist）
		      POLLHUP 断开连接 
		  e.g. p.register(sockfd,POLLIN|POLLERR)

p.unregister(fd)
功能：取消对IO的关注
参数：IO对象或者IO对象的fileno
```

```python
events = p.poll()d
功能： 阻塞等待监控的IO事件发生
返回值： 返回发生的IO
        events格式  [(fileno,event),()....]
        每个元组为一个就绪IO，元组第一项是该IO的fileno，第二项为该IO就绪的事件类型
```

poll_server 步骤
	   
	【1】 创建套接字
	【2】 将套接字register
	【3】 创建查找字典，并维护
	【4】 循环监控IO发生
	【5】 处理发生的IO


#### epoll方法

***代码实现: day5/epoll_server.py***

1. 使用方法 ： 基本与poll相同

	 * 生成对象改为 epoll()
   * 将所有事件类型改为EPOLL类型
	
2. epoll特点

   * epoll 效率比select poll要高
   * epoll 监控IO数量比select要多
   * epoll 的触发方式比poll要多 （EPOLLET边缘触发）


### 协程技术

#### 基础概念

1. 定义：纤程，微线程。是允许在不同入口点不同位置暂停或开始的计算机程序，简单来说，协程就是可以暂停执行的函数。(例如生成器函数 yield)

#####生成器举例:
    def fun()
        print("strat")
        yield 1
        print("end")
    g = fun()
    g.__next__()
    g.__next__()

2. 协程原理 ： 记录一个函数的上下文，协程调度切换时会将记录的上下文保存，在切换回来时进行调取，恢复原有的执行内容，以便从上一次执行位置继续执行。
>在应用层通过函数的暂停跳转实现多个任务间切换执行,其中每个函数都可以从任意位置暂停跳出并继续执行

应用: 协程也可以作为一个IO并发模板,并且占用的资源极少

3. 协程优缺点
	
>优点
>>1. 协程完成多任务占用计算资源很少
>>2. 由于协程的多任务切换在应用层完成，因此切换开销少
>>3. 协程为单线程程序，无需进行共享资源同步互斥处理

>缺点
>
>> 协程的本质是一个单线程，无法利用计算机多核资源(能够利用计算机多核资源的只有进程和线程)


--------------------------------
####扩展延伸@标准库协程的实现

python3.5以后，使用标准库asyncio和async/await 语法来编写并发代码。asyncio库通过对异步IO行为的支持完成python的协程。虽然官方说asyncio是未来的开发方向，但是由于其生态不够丰富，大量的客户端不支持awaitable需要自己去封装，所以在使用上存在缺陷。更多时候只能使用已有的异步库（asyncio等），功能有限

------------------------------

#### 第三方协程模块

1.  greenlet模块

***示例代码: day6/greenlet_0.py***

* 安装 ： sudo  pip3 install greenlet

* 函数 

```python
greenlet.greenlet(func)
功能：创建协程对象
参数：协程函数

g.switch()
功能：选择要执行的协程函数
```

2. gevent模块

***示例代码: day6/gevent_test.py***
***示例代码: day6/gevent_server.py***
				
* 安装：sudo pip3 install gevent

* 函数

```python
gevent.spawn(func,argv)
功能: 生成协程对象
参数：func  协程函数
     argv  给协程函数传参（不定参）
返回值： 协程对象

gevent.joinall(list,[timeout])
功能: 阻塞等待协程执行完毕
参数：list  协程对象列表
     timeout 超时时间

gevent.sleep(sec)
功能: gevent睡眠阻塞
参数：睡眠时间

* gevent协程只有在遇到gevent指定的阻塞行为时才会自动在协程之间进行跳转
如gevent.joinall(),gevent.sleep()带来的阻塞
```

* monkey脚本

>作用：在gevent协程中，协程只有遇到gevent指定类型的阻塞才能跳转到其他协程，因此，我们希望将普通的IO阻塞行为转换为可以触发gevent协程跳转的阻塞，以提高执行效率。

> 转换方法：gevent 提供了一个脚本程序monkey,可以修改底层解释IO阻塞的行为，将很多普通阻塞转换为gevent阻塞。

> 使用方法

>>【1】 导入monkey

			from gevent  import monkey

>>【2】 运行相应的脚本，例如转换socket中所有阻塞

			monkey.patch_socket()

>>【3】 如果将所有可转换的IO阻塞全部转换则运行all

			monkey.patch_all()

>>【4】 注意：脚本运行函数需要在对应模块导入前执行



### HTTPServer v2.0 

***day6/http_server.py***

  1. 主要功能 ：
	  【1】 接收客户端（浏览器）请求
		【2】 解析客户端发送的请求
		【3】 根据请求组织数据内容
		【4】 将数据内容形成http响应格式返回给浏览器
	
	2. 升级点 ：
	    【1】 采用IO并发，可以满足多个客户端同时发起请求情况
		【2】 做基本的请求解析，根据具体请求返回具体内容，同时满足客户端简单的非网页请求情况
        【3】 通过类接口形式进行功能封装

####http_server技术分析:

    1.使用tcp通信,基于http协议格式
    2.select io 多路复用

    结构: 采用多路封装

    类的接口设计: 

    1. 在用户使用各个角度进行流程设计
        * 当需要完成的功能是一个比较大的概括的功能,可以提供继承方法,让别人使用时继承你的类

        * 针对一个非常具体的功能,尽量帮使用者实现更多的功能,让用户尽可能少的修改代码或者尽可能简单的使用

        * 不能够替用户决定的属性,让用户传参

        * 不能够替用户决定的复杂功能,让用户去重写
