1.表达式：由数字或数字和运算符组成，只要能放到赋值符号右边的都叫表达式。
   作用：通常让计算机做一些事情并返回结果

2.赋值语句：
    作用：创建一个变量或改变一个变量的绑定关系
    变量一 = 变量二 = 变量三 = 表达式 # 这是正确的
3.引用计数：
    每个对象都会记录有几个变量绑定（引用）自身，当引用的数量为0时，则此对象将被销毁，此种像自动化内存管理的方式叫“引用计数”。
4.小整数对象池
    Cpython中整数-5至256，永远存在与小整数对象池中，不会被释放并可重复使用。
5.比较运算符：
     比较运算符返回布尔值，True False
6.函数调用：
     函数名（传参列表）  #这就是函数的调用
     说明：函数调用是一个表达式，一定会返回一个对象的引用关系（或者返回一个None）
7.语句               
   语句是由一部分表达式组成，通常一条语句是可以独立执行来完成一部分事情并形成结果
   说明：一条语句建议卸载一行内
        多条语句写在一行也可以，但是要用分号（；）隔开
8.if 语句：
    作用：让程序根据条件选择性的执行某条语句或某些语句
    说明：elif 可以有0个，1个，或多个
         else 只能有一个或者零个。
9.布尔运算： not and or
    短路运算：一旦结果确定，后面的表达式不在执行
10.字符串 str 
    作用：记录文本信息（或文字信息）
    表示方式：在程序里面，非注释中凡是用引号括起来的部分都是字符串。
11.raw字符串（原始字符串） 
    r'字符串'、
    作用：让转义字符 \ 无效
12.ascii编码 0 ～ 127
   unicode16 编码（0 ～ 65535） 
   unicode32 编码（0 ～ 2**32 -1）
13.字符串格式化表达式：
    作用：生成一定格式的字符串
    运算符： % 
14.while 语句
   作用：根据一定条件，重复的执行一条语句或多条语句
   注意事项：
     1.要控制循环的真值表达式来防止死循环
     2.通常用真值表达式内的循 环变量来控制循环条件
     3.通常再循环语句内部改变循环变量来控制循环的次数和变量的走向。
15.break
    作用：用于循环语句中，用来表示终止当前循环的执行。
16.for语句的作用：
    用来遍历可迭代对象的数据元素
    可迭代对象是指能依次获取数据元素的对象。
17.range函数
  作用：
    用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)   
18.continue 语句
  作用：
    用于循环语句(while,for语句)中,不再执行本次循环内continue之后的语句，重新开始一次新的循环
  说明：
    1. 在while语句中执行 continue语句，将直接跳转到while语句的真值表达式处重新判断循环条件
    2. 在for语句中执行continue语句，将会从可迭代对象中取下一个元素，绑定变量后再次进行循环
  在while语句和for语句中 运行结果不同?
      while 中 跳转到真值表达式处
      for 中 跳转到向可迭代对象取数据处
19.列表 list
  列表的定义：
     列表是由一系列元素组成的，元素与元素之间可能没有任何的关联关系，但他们之间有先后顺序关系。列表是一种容器，是一种序列，是有先后顺序的。
  创建方式：
     l = [] l = list(iterable)
     L.extend(lst) 向列表追加另一个列表
     L.pop([index]) 删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系。
     L.index(v [, begin[, end]]) 返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误
     L.insert(index, obj) 将某个元素插放到列表中指定的位置
     L.count(x) 返回列表中元素的个数
     L.remove(x) 从列表中删除第一次出现在列表中的值 
     切片 l[start:end:sep]
20.列表的索引：
  语法:
    列表[整数表达式]
21.用于序列的函数
   any(x)    真值测试, 如果容器内其中一个值为True则返回True,否则返回False
   all(x)    真值测试, 容器内所有元素的布尔值为True才返回True
22.浅拷贝 shallow copy 和 深拷贝 deep copy
 浅拷贝:
    是指复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程
 深拷贝：
    import copy
    深拷贝通常只对可变对象进行深层复制，不可变对象通常不会被复制
23.字符串文本解析方法 split 和 join
   S.split(sep=None)  将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时，用空白字符作为分隔符分割
   S.join(iterable)  用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串

24.列表推导式 list comprehension
  列表推导式是用可迭代对象依次生成带有多个元素的列表的表达式

  作用：
    用简易方法生成列表
  语法:
    [表达式 for 变量 in 可迭代对象]
    或
    [表达式 for 变量 in 可迭代对象 if 真值表达式]

25.元组 tuple
    元组是不可改变的序列，同list一样，元组可以存放任意类型的元素
  表示方法:
    用小括号 () 括起来，单个元素括起来后加逗号(,)区分单个对象还是元组
  创建空元组的字面值
    t = ()
  元组的构造(创建)函数tuple
    tuple()          生成一个空元组，等于同()
    tuple(iterable)  用可迭代对象生成一个元组
26.type(x)  函数用来返回 x 的类型
27.字典 dict
  什么是字典:
    字典是一种可变的容器,可以存储任意类型的数据
    字典中的每个数据都是用'键'进行索引的，而不像序列可以用下标(index)来进行索引
    字典中的数据没有先后顺序关系, 字典的存储是无序的
    字典中的数据以键(key)-值(value) 对的形式进行映射存储
    字典的键不能重复，具只能用"不可变类型"作为字典的键

  字典的字面值的表示方式:
    字典的表示方式以 {} 括起来,以冒号(:) 分隔键-值对, 各键-值对之间用逗号(,)分割开
  字典的构造函数dict
    dict()   生成一个 空字典，等同于 {}
    dict(iterable)  用可迭代对象初始化一个字典
    dict(**kwargs)  用命名关键字传参形式生成一个字典
28.字典的键为不可变类型:
  bool, int, float, complex, str, tuple, frozenset(固定集合), bytes(字节串)
  包括: None
29.is 运算符是用id来判断
  **不要把 is 当成 == 来用**
  a is None  # 用来判断 a 是否绑定None对象
30.del 语句:
  可以删除索引
    del L[0] #L是列表
  **可以删除切片**（remove和pop都不可以）
    del L[1:5]
31.字典的迭代访问：
  容器是可迭代对象，字典只能对键进行迭代访问
32.字典 VS 列表
  1. 都是可变对象
  2. 索引方式不同, 列表用整数索引，字典用键索引
  3. 字典的查找速度可能会快于列表(重要)
  4. 列表的存储是有序的，字典的存储是无序的
33.集合 set
    集合是可变的容器
    集合内的数据对象都是唯一的（不能重复多次的)
    集合是无序的存储结构，集合中的数据没有先后顺序关系
    集合内的元素必须是不可变对象
    集合是可迭代对象
    集合是相当于只有键没有值的字典(键则是集合的数据)
34.创建空的集合:
     set()
   创建非空的集合:
     s = {1, 2, 3, 4}

    集合的构造函数 set
      set()  创建一个空的集合对象(不能用{}来创建空集合)
      set(iterable)  用可迭代对象创建一个新的集合对象
35.集合的运算:
    交集， 并集，补集，子集，超集
   运算符:
      & | - ^ < <= > >= == !=
      in / not in
36.固定集合 frozenset
    固定集合是不可变的，无序的，含有不重复元素的集合

    作用：
      固定集合可以作为字典的键，还可以作为集合的值

    创建空的固定集合
        fs = frozenset()
    创建非空的固定集合:
        frozenset(iterable)  用可迭代对象创建新的固定集合
37.固定集合的方法:
  相当于集合的全部方法(去掉修改集合的方法)
38.列表 ，字典，集合对象优缺点:
    1. 都为可变
    2. 列表的尾部插入速度比较快，从中间插入和头插数据速度慢
    3. 列表有序
    4. 字典添加，删除，修改速度快于列表
    5. 集合的添加，删除快于列表，且不能存储重复元素
39.函数 function
    什么是函数:
      函数是可以重复执行的语句块，可以重复调用。
    作用：
      1. 用于封装可重复执行的语句，提高语句的可重用性
      2. 定义用户级别的函数
40.函数的语法说明：
    1. 函数的名字就是语句块的名称
    2. 函数名的命名规则与变量名命名规则相同（必须为标识符)
    3. 函数名是一个变量（不要轻易对其赋值）
    4. 函数的自己的命字空间，在函数内部可以访问外部的变量，但外部的语句不能访问函数内部的变量
    5. 函数如果不需要传入参数，则参数列表可以为空
    6. 语句部分不能为空，如果为空需要填充pass语句
41.函数调用:
    函数名(实际调用传递参数)
    注:
      实际调用传递参数 简称"实参"
    调用说明：
       1. 函数调用是一个表达式
       2. 如果没有return语句，函数执行完后返回None对象
       3. 如果函数需要返回其它的对象，需要用到return语句
42.return 语句:
  语法:
    return [表达式] #思考中括号的作用，中括号里面的东西可以怎么样。
  作用:
    用于函数中,结束当前函数的执行,返回到调用函数的地方,同时返回一个对象的引用关系
  说明:
    1. return语句后跟的表达式可以省略,省略后相当于return None
    2. 如果函数内没有return语句,则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)
    3. 函数调用能够返回一个对象的引用
43.python函数的参数传递
     传递方式:
       位置传参
       序列传参
       关键字传参
       字典关键字传参
44.位置传参:
      实际调用参数(实参) 的对应关系与形式参数(形参)的对应关系是按位置来依次对应的
45.序列传参:
      序列传参是批在函数调用过程中,用 * 将序列拆解后按位置进行传递的传参方式
      实参和形参通过序列传递和匹配
46.关键字传参
      是指传参时,按着形参的名称给形参赋值
      实参和形参按名称进行匹配
47.字典关键字传参:
      实参为字典,用**拆解字典后再进行关键字传参
  说明:
    字典的键名和形参名必须一致
    字典的键名必须为字符串
    字典的键名要在形参中存在
48.综合传参:
     函数的传参方式在能确定形参能唯一匹配到相应实参的情况下可以任意组合
   注:
      通常位置传参和序列传参先传递,其次是关键字传参和字典关键字传参
49.函数的缺省参数
  语法:
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ...): 
        语句
  说明:
    缺省参数必须自右至左依次存在
    缺省参数可以有0个,1个,多个,甚至全部都有缺省参数
    缺省参数的绑定对象存在于函数内,同函数的生命周期一致
50.函数参数说明:
   位置形参,缺省参数,星号元组形参,命名关键字形参,双星号字典形参可以混合使用
   函数参数自左至右的顺序为:
     1. 位置形参
     2. 星号元组形参
     3. 命名关键字形参
     4. 双星号字典形参
51.函数可以做为另一个函数的返回值:
    函数可以返回另一个函数
52.全局变量和局部变量
  局部变量:
    1. 定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
    2. 局部变量只能在函数内部使用
    3. 局部变量在函数调用时才能够被创建,在函数调用之后会自动销毁
  全局变量:
    定义在函数外部,模块内部的变量称为全局变量
    全局变量,所有函数都可以直接访问(但函数内部不能直接修改全局变量的绑定关系)
53.局部变量说明:
  1. 在函数内首次对变量赋值是创建局部变量,再次为变量赋值是修改局部变量的绑定关系
  2. 在函数内部的赋值语句不会对全局变量造成影响

54.python作用域:
  作用域也叫命名空间,是访问变量时查找变量名的范围空间。（换句话说命名空间也就是作用域。）
55.python的四个作用域LEGB
        作用域            英文解释            英文简写
   局部作用域(函数内)     Local(function)         L
   外部嵌套函数作用域  Enclosing function locals  E
   函数定义所在模块的作用域  Global(module)        G
   python 内置模块的作用域  Builtin(python)       B
56.变量名的查找规则(顺序):
   1. 查找本地变量
   2. 查找包裹此函数的外部嵌套函数内部的变量
   3. 全局变量
   4. 内置变量
57.global 语句
  作用:
    1. 告诉解释执行器,global语句声明的一个或多个变量,这些变量的作用域为模块级的作用域的变量,也称作全局变量
    2. 全局声明(global) 将赋值变量映射到模块文件内部的作用域
  语法:
    global 变量1, 变量2, ...
  说明:
    1. 全局变量如果要在函数内部被赋值,则必须经过全局声明(否则会被认为是局部变量)
    2. 全局变量在函数内部不经过声明就可以直接访问
    3. 不能先声明局部变量,再用global声明为全局变量,此做法不附合规则
    4. global变量列表里的变量名不能出现在此作用域内的形参列表里
58.nonlocal语句
  作用:
    告诉解释器, nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量
  语法:
    nonlocal 变量名1, 变量名2, ....
  说明:
    1. nonlocal语句只能在被嵌套函数内部进行使用
    2. 访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
    3. 当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近一层的变量进行操作
    4. nonlocal语句的变量列表的变量名不能出现在此函数的参数列表里
59.lambda 表达式(又名匿名函数表达式)
  作用:
    创建一个匿名函数对象
    同def类似，但不提供函数名
  语法:
    lambda [形参1, 形参2, ...] : 表达式
  语法说明:
    1. lambda 只是一个表达式，它用来创建一个函数对象
    2. 当lambda表达式调用时，先执行冒号后的表达式,并返回表达式的结果的引用
    3. lambda 表达式创建的函数只能包含一条表达式
    4. lambda比函数简单，且可以随时创建和销毁,有利于减少程序的偶合度
60.eval函数:
  作用：
    把一个字符串当成一个表达式执行，返回表达式执行后的结果
  格式:
    eval(source, globals=None, locals=None)
61.exec函数:
  作用：
    把一个字符串当成程序来执行
  格式：
    exec(source, globals=None, local=None)
62.什么是类
  拥有相同属性和行为的对象分为一组,即为一个类
  类是用来描述对象的工具,用类可以创建此类的对象(实例)
63.类的创建语句 class 语句
  语法:
    class 类名(继承列表):
        '''类的文档字符串'''
        实例方法定义
        类变量的定义
        类方法(@classmethod) 定义
        静态方法(@staticmethod) 定义 
  作用:
    创建一个类
    类用于描述对象的行为和属性
    类用于创建此类的一个或多个对象(实例)
  说明:
    继承列表可以省略
    类名必须是一个标识符(写变量的命名相同,建议首字母大写)
    类名实质上就是变量,它绑定一个类)
64.构造函数
  构造函数调用表达式
    类名([创建传参列表])
  作用:
    创建这个类的实例对象,并返回此实例对象的引用关系
65.实例说明:
  实例有自己的作用域和名字空间,可以为该实例添加实例变量(属性)
  实例可以调用实例方法和类方法 
  实例可以访问实例变量和类变量
66.实例方法(instance method)
  定义语法:
    class 类名(继承列表):
        def 实例方法名(self, 参数1, 参数2, ...):
            '''方法的文档字符串'''
              语句块
  作用:
    用于描述一个对象的行为.让此类型的全部对象都拥有相同的行为
  说明:
    实例方法的实质是函数,是定义在类内的函数
    实例方法至少有一个形参,第一个形参用来调用这个方法的实例,
      一般命名为'self'
  调用语法:
    实例.实例方法名(调用传参)
    类名.实例方法名(实例, 调用传参)
 67.实例变量(也称为实例属性)
  每个实例可以有自己的变量,称为实例变量(实例属性)
  语法:
    实例.属性名
  作用:
    记录每个对象自身的数据
  赋值规则:
    首次为属性赋值则创建此属性
    再次为属性赋值则改变属性的绑定关系
68.删除属性
  del 语句
    语法:
       del 对象.实例变量名
69. 类的 __slots__ 属性
  作用：
  　　限定一个类创建的实例只能有固定的属性(实例变量)
  说明:
    __slots__ 属性是一个列表，字表的值是字符串
    含有__slots__属性的类所创建的对象没有__dict__字典
70.类方法 @classmethod
    类方法是操作类的方法，类方法属于类，不属于该类创建的对象

    说明:
      类方法需要使用@classmethod装饰器定义
      类方法的第一个参数用来绑定类，约定写为cls
      类和对象实例都可以调用类方法
      类方法不能访问此类创建的对象的属性
71.静态方法　＠staticmathod
    静态方法是定义在类的内部的函数，此函数作用域是类的内部
    说明:
      静态方法需要使用@staticmethod装饰器定义　
      静态方法与普通函数的定义相同，不需要传入self和cls
      静态方法只能凭借该类和实例来调用
      静态方法不能访问类变量和实例变量
72.继承 inheritance 和 派生 derived
    什么是继承 / 派生
       继承是从已有类中派生出新类，新类具有原类的数据属性和行为,并能扩展新的能力
       派生就是从一个已有的类衍生出新类，在新的类上添加新的属性和行为
    作用：
  　　  1.　用继承派生机制，可以将一些共有功能加在基类中，实现代码的共享
        2. 在不改变超类的代码的基础上，改变原有的功能
    名词:
        基类(base class) / 超类(super class) / 父类(father class)
        派生类(derived class) / 子类(child class)
73.单继承:
  语法:
    class 类名(超类名):
        语句块
74.继承说明:
    任何类都直接或间接的继承自object类
    object类是一切类的超类

    类内的　__base__属性
　　  此属性用来记录此类的基类
75.覆盖: override
  什么是覆盖
  　　覆盖是指在有继承派生关系的类中，子类中实现了与基类(超类)同名的方法，在子类实例调用方法时，实际调用的是子类中的覆盖版本，这种现象叫做覆盖
76.当覆盖发生时，子类对象能否调用父类中的方法？
   super函数
     super(type, obj)  返回绑定超类的实例（要求obj必须为type类型的实例)
     super()  返回绑定超类的实例，等同于super(__class__, 实例的第一个参数), 且必须在方法内调用
   作用：
　　   返回超类的实例，用超类实例来调用其自身的方法
   说明：
　　当子类实现了__init__方法后，父类的__init__方法将被覆盖，即不再会主动调用父类的__init__方法，会引起父类的属性得不到初始化,此时需要显式调用父类的初始化方法
77.issubclass 函数
   issubclass(cls, class_or_tuple)  判断一个类是否是继承自其它的类，如果此类cls 是class 或tuple中的一个派生子类，则返回True, 否则返回False
78.封装 enclosure
    封装是指隐藏类的实现细节．让使用者不关心这些细节;
    封装的目的是让使用者通过尽可能少的使用实例变量名(属性)操作对象
79.私有属性和方法
　　python类中以双下划线('__')开头，不以双下划线结尾的标识符为私有成员
　　　私有成员只能被方法调用，不能在子类或其它地方使用
    私有成员有两种:
      私有属性
      私有方法
80.多态　 polymorphic
　　字面意思：多种状态
　　多态是指在有继承／派生关系的类中，调用基类对象的方法，实际能 调用子类的覆盖方法的现象叫多态
   多态说明:
     多态调用方法与对象相关，不与类相关
     python的全部对象只有"运行时状态(动态)", 没有"C++/Java"里的"编译时状态（静态）"
81.面向对象编程语言的特征:
     封装
     继承
     多态
82.多继承的问题（缺陷）
     标识符(名字空间)冲突的问题
     要谨慎使用多继承
83.函数重写 overwrite
  什么是函数重写
    在自定义的类中，通过添加特定的方法，让自定义的类生成的对象(实例) 能象内建对象一样进行内建函数操作
84.Python 用下划线作为变量前缀和后缀指定特殊变量
    _xxx 不能用’from module import *’导入
    __xxx__ 系统定义名字
    __xxx 类中的私有变量名
    核心风格：避免用下划线作为变量名的开始。
   “单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；
   “双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。
85.迭代器(高级)
  什么是迭代器
    可以通过 next(obj) 函数取值的对象，就是迭代器
  迭代器协议:
    迭代器议是指对象能够使用next函数获取下一项数据，在没有下一项数据时触发一个StopIteration异常来终止迭代的约定
  迭代器协议的实现方法:
    在类内需要定义 __next__(self)方法来实现迭代器协议
  语法形式:
    class MyIterator:
        def __next__(self):
            迭代器协议
            return 数据
86.特殊属性：
   >>> Class1.__doc__ # 类的帮助信息 'Class1 Doc.' 
   >>> Class1.__name__ # 类的名称 'Class1' 
   >>> Class1.__module__ # 类型所在模块 '__main__' 
   >>> Class1.__bases__ # 类型所继承的基类 (<type 'object'>,) 
   >>> Class1.__dict__ # 类型字典，存储所有类的成员信息。 <dictproxy object at 0x00D3AD70> 
   >>> Class1().__class__ # 类型 <class '__main__.Class1'> 
   >>> Class1().__module__ # 实例类型所在模块 '__main__' 
   >>> Class1().__dict__ # 对象字 0典，存储所有实例成员信息。 {'i': 1234}
87.属性管理函数
  getattr(obj, name[, default])   从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误
    
  hasattr(obj, name)  用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误
    
  setattr(obj, name, value)   给对象obj的名为name的属性设置相应的值value, set(x, 'y', v) 等同于 x.y = v
    
  delattr(obj, name)  删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y 
88.异常(高级)
with语句
  语法：
    with 表达式1 [as 变量名1], 表达式2 [as 变量名2], ...

  作用:
    用于对资源访问的场合，确保使用过程中不管是否发生异常，都会执行必要有"清理"操作，并释放资源.
    如:
      文件打开后自动关闭，线程中锁的自动获取和释放(线程后面会讲)
  说明:
    with语句与try-finally相似，并不会改变异常状态
    as 子句用于绑定表达式创建的对象
89.Python 对象 中以双下划线开头和结尾的属性称为特殊属性，由于对象的方法也属于属性，因此以双下划线开头和结尾的方法称为特殊方法。对这些对象执行一些特定的运算时，Python会自动视图调用这些实例的特殊方法，从而在Python中可以很轻易地实现运算符的重载。
   1. C.__name__
　　对象的名称，比如类型(type, class)对象的名称就是系统内置的或自定义的名称字符串，类型的实例通常没有属性 __name__
   2. C.__bases__
　　元组，包含 类型对象(type, class) C 的全部基类，类型的实例通常没有属性 __bases__。
   3. x.__class__
　　 Python对象，是实例或类型 x 所属的类型，其值等于 type(x)
   4. x.__dict__
　　字典，除了一些特殊的属性，实例、类型等对象的所有属性，都放置在其 __dict__ 字典中
90.运算符重载:
  什么是运算符重载
    让自定义的类生成的对象（实例）能够使用运算符进行操作
  作用：
    让实例像数学表达式一样进行运算操作
    让程序简洁易读
  说明:
    运算符重载方法的参数已经有固定的含义，不建议改变原有的含义














